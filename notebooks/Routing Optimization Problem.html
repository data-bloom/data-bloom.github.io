<meta charset="utf-8" />
    <title>Routing Optimization Problem</title>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.1.10/require.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
    <link href="css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom CSS -->
    <link href="css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link href="css/style.css" rel="stylesheet" type="text/css">
    <link rel="shortcut icon" href="bloom.ico" type="image/x-icon">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <style type="text/css">
        {
            {
                css
            }
        }
    </style>
    <style type="text/css">
        {
            {
                css
            }
        }
    </style>
    <style type="text/css">
        {
            {
                css
            }
        }
    </style>
    

    <!-- Can put analytics code here, if desired -->

    <style type="text/css">
        /* Overrides of notebook CSS for static HTML export */
        
        body {
            overflow: visible;
            padding: 8px;
        }
        
        div#notebook {
            overflow: visible;
            border-top: none;
        }
        
        @media print {
            div.cell {
                display: block;
                page-break-inside: avoid;
            }
            div.output_wrapper {
                display: block;
                page-break-inside: avoid;
            }
            div.output {
                display: block;
                page-break-inside: avoid;
            }
        }
    </style>

    <link rel="stylesheet" href="ipynb.css">
    <link rel="stylesheet" href="/css/five.css">

    <!-- Loading mathjax macro -->
    <!-- Load mathjax -->
    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
    <!-- MathJax configuration -->
    <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ['$','$'], ["\\(","\\)"] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
            processEscapes: true,
            processEnvironments: true
        },
        // Center justify equations in code and markdown cells. Elsewhere
        // we use CSS to left justify single line equations in code cells.
        displayAlign: 'center',
        "HTML-CSS": {
            styles: {'.MathJax_Display': {"margin": 0}},
            linebreaks: { automatic: true }
        }
    });
    </script>
    <!-- End of mathjax configuration -->
    <!-- Navigation -->
    <div class="container row">
        <a class="pull-right navbar-brand" href="http://data-bloom.com">Data Bloom</a>
    </div>
    <div tabindex="-1" id="notebook" class="border-box-sizing">
        <div class="container" id="notebook-container">
            
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="Efficient-Routing">Efficient Routing<a class="anchor-link" href="#Efficient-Routing">&#182;</a></h1><p>You knew the traveling salesman problem is NP-complete. From wikipedia -- <a href="https://en.wikipedia.org/wiki/Travelling_salesman_problem">https://en.wikipedia.org/wiki/Travelling_salesman_problem</a></p>
<blockquote><p>The traveling salesman problem (TSP) asks the following question: "Given a list of cities and the distances between each pair of cities, what is the shortest possible route that visits each city exactly once and returns to the origin city?" It is an NP-hard problem in combinatorial optimization, important in operations research and theoretical computer science.</p>
</blockquote>
<p>Yet consider a simple everyday example of garbage collection, USPS delivery, meals-on-wheels, or everyday GPS navigation. There is a need for a scalable solution to minimize the distance and maximize resource utilization. This routing need has many applications.</p>
<p>When theoretical solutions may be computationally costly, heuristic solutions offer a faster (perhaps semi-optimal) solutions. One such routing heuristic is <a href="http://connection.ebscohost.com/c/articles/6691618/minimal-technology-routing-system-meals-wheels">http://connection.ebscohost.com/c/articles/6691618/minimal-technology-routing-system-meals-wheels</a> by Dr. Bartholdi that uses Hilbert space filling curves to offer short routes to TSP problems.</p>
<p>Further more, say when you are comparing records like one hotel in a city with nearby businesses like a subway for making exchange referrals, computing every business's Euclidean intersection with other is quadratic and disallowed in Hadoop/Spark. To limit the join space means we use a equality predicate like zipcode (only comparing businesses that share a zipcode) to limit search. Unfortunately, the zip codes are not contiguous for contiguous areas and thus do need a contiguous surrogate like Hilbert space filling curves discussed below to make the search perform better.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Top-20-Cities">Top 20 Cities<a class="anchor-link" href="#Top-20-Cities">&#182;</a></h2><p>Let us suppose a gopher wants to travel to the top 20 US populated cities from New York.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Data">Data<a class="anchor-link" href="#Data">&#182;</a></h2><p>The top 20 cities data is populated at <a href="https://en.wikipedia.org/wiki/List_of_United_States_cities_by_population">https://en.wikipedia.org/wiki/List_of_United_States_cities_by_population</a></p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[1]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython2"><pre><span></span><span class="c1"># Read data from the web; the top 20 cities</span>
<span class="n">cities</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_html</span><span class="p">(</span><span class="s1">&#39;https://en.wikipedia.org/wiki/List_of_United_States_cities_by_population&#39;</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="mi">0</span><span class="p">)[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>

<span class="c1"># Display a preview of the cities</span>
<span class="n">pd_display</span><span class="p">(</span><span class="n">cities</span><span class="p">,</span> <span class="s2">&quot;Top 20 most populous cities in the US from Wikipedia&quot;</span><span class="p">)</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area"><div class="prompt"></div>

<div class="output_html rendered_html output_subarea ">
<h4>Top 20 most populous cities in the US from Wikipedia</h4>
</div>

</div>

<div class="output_area"><div class="prompt"></div>

<div class="output_html rendered_html output_subarea ">
<div>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>2015 rank</th>
      <th>City</th>
      <th>State[5]</th>
      <th>2015 estimate</th>
      <th>...</th>
      <th>Change</th>
      <th>2014 land area</th>
      <th>2010 population density</th>
      <th>Location</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1</td>
      <td>New York[6]</td>
      <td>New York</td>
      <td>8550405</td>
      <td>...</td>
      <td>7000459040849855290♠+4.59%</td>
      <td>7002302600000000000♠302.6 sq mi 783.8 km2</td>
      <td>7004270120000000000♠27,012 per sq mi 10,430 km−2</td>
      <td>40°39′51″N 73°56′19″W﻿ / ﻿40.6643°N 73.9385°W﻿...</td>
    </tr>
    <tr>
      <th>1</th>
      <td>2</td>
      <td>Los Angeles</td>
      <td>California</td>
      <td>3971883</td>
      <td>...</td>
      <td>7000472659936228800♠+4.73%</td>
      <td>7002468700000000000♠468.7 sq mi 1,213.9 km2</td>
      <td>7003809200000000000♠8,092 per sq mi 3,124 km−2</td>
      <td>34°01′10″N 118°24′39″W﻿ / ﻿34.0194°N 118.4108°...</td>
    </tr>
    <tr>
      <th>2</th>
      <td>3</td>
      <td>Chicago</td>
      <td>Illinois</td>
      <td>2720546</td>
      <td>...</td>
      <td>6999925508922324480♠+0.93%</td>
      <td>7002227600000000000♠227.6 sq mi 589.6 km2</td>
      <td>7004118420000000000♠11,842 per sq mi 4,572 km−2</td>
      <td>41°50′15″N 87°40′54″W﻿ / ﻿41.8376°N 87.6818°W﻿...</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>17</th>
      <td>18</td>
      <td>Seattle</td>
      <td>Washington</td>
      <td>684451</td>
      <td>...</td>
      <td>7001124521079091780♠+12.45%</td>
      <td>7001839000000000000♠83.9 sq mi 217.4 km2</td>
      <td>7003725100000000000♠7,251 per sq mi 2,800 km−2</td>
      <td>47°37′14″N 122°21′03″W﻿ / ﻿47.6205°N 122.3509°...</td>
    </tr>
    <tr>
      <th>18</th>
      <td>19</td>
      <td>Denver[12]</td>
      <td>Colorado</td>
      <td>682545</td>
      <td>...</td>
      <td>7001137275517447070♠+13.73%</td>
      <td>7002153000000000000♠153.0 sq mi 396.3 km2</td>
      <td>7003392300000000000♠3,923 per sq mi 1,515 km−2</td>
      <td>39°45′42″N 104°52′50″W﻿ / ﻿39.7618°N 104.8806°...</td>
    </tr>
    <tr>
      <th>19</th>
      <td>20</td>
      <td>El Paso</td>
      <td>Texas</td>
      <td>681124</td>
      <td>...</td>
      <td>7000493020561651830♠+4.93%</td>
      <td>7002255200000000000♠255.2 sq mi 661.1 km2</td>
      <td>7003254300000000000♠2,543 per sq mi 982 km−2</td>
      <td>31°50′54″N 106°25′37″W﻿ / ﻿31.8484°N 106.4270°...</td>
    </tr>
  </tbody>
</table>
<p>20 rows × 9 columns</p>
</div>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Let us be selective in which data we choose.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[2]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython2"><pre><span></span><span class="c1"># Compute lat-lng codes and citynames. We are not interested in others</span>
<span class="n">interested_cities</span> <span class="o">=</span> <span class="n">cities</span><span class="p">[[</span><span class="s1">&#39;City&#39;</span><span class="p">,</span> <span class="s1">&#39;Location&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

<span class="c1"># Strip any footnote references from the city name</span>
<span class="n">interested_cities</span><span class="p">[</span><span class="s1">&#39;City&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">interested_cities</span><span class="p">[</span><span class="s1">&#39;City&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;[&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>

<span class="c1"># Make the dataframe index on city</span>
<span class="n">interested_cities</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">&#39;City&#39;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">drop</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="c1"># Write logic to parse lat lon code</span>
<span class="kn">from</span> <span class="nn">LatLon</span> <span class="kn">import</span> <span class="n">string2latlon</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="k">def</span> <span class="nf">parse_lat_lon</span><span class="p">(</span><span class="n">code_str</span><span class="p">):</span>
    <span class="c1"># Strip the degree symbol</span>
    <span class="p">(</span><span class="n">lat</span><span class="p">,</span><span class="n">lng</span><span class="p">)</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;|&#39;</span><span class="p">,</span> <span class="s1">&#39; &#39;</span><span class="p">),</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s1">r&#39;([NEWS])&#39;</span><span class="p">,</span> <span class="s1">r&#39;|\1&#39;</span><span class="p">,</span> <span class="n">code_str</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>
    <span class="c1"># Return lat lon parsed from direction</span>
    <span class="k">return</span> <span class="n">string2latlon</span><span class="p">(</span><span class="n">lat</span><span class="p">,</span> <span class="n">lng</span><span class="p">,</span> <span class="s1">&#39;D</span><span class="si">% %</span><span class="s1">H&#39;</span><span class="p">)</span>

<span class="c1"># Collect only lat long codes</span>
<span class="n">interested_cities</span><span class="p">[</span><span class="s1">&#39;Location&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">interested_cities</span><span class="p">[</span><span class="s1">&#39;Location&#39;</span><span class="p">]</span><span class="o">.</span>\
    <span class="nb">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">parse_lat_lon</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]))</span>
    
<span class="c1"># Collect latitude</span>
<span class="n">interested_cities</span><span class="p">[</span><span class="s1">&#39;Latitude&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">interested_cities</span><span class="p">[</span><span class="s1">&#39;Location&#39;</span><span class="p">]</span><span class="o">.</span>\
    <span class="nb">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()))</span>

<span class="c1"># Collect longitude</span>
<span class="n">interested_cities</span><span class="p">[</span><span class="s1">&#39;Longitude&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">interested_cities</span><span class="p">[</span><span class="s1">&#39;Location&#39;</span><span class="p">]</span><span class="o">.</span>\
    <span class="nb">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()))</span>
    
<span class="c1"># Center the (0,0) of the map on the center of the plan</span>
<span class="n">interested_cities</span><span class="p">[</span><span class="s1">&#39;RelLongitude&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">interested_cities</span><span class="p">[</span><span class="s1">&#39;Longitude&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">interested_cities</span><span class="p">[</span><span class="s1">&#39;Longitude&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>

<span class="n">interested_cities</span><span class="p">[</span><span class="s1">&#39;RelLatitude&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">interested_cities</span><span class="p">[</span><span class="s1">&#39;Latitude&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">interested_cities</span><span class="p">[</span><span class="s1">&#39;Latitude&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
    
<span class="c1"># Display preview of lat-lng and city</span>
<span class="n">pd_display</span><span class="p">(</span><span class="n">interested_cities</span><span class="p">,</span> <span class="s2">&quot;Latitude and Longitude of the 20 cities&quot;</span><span class="p">)</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area"><div class="prompt"></div>

<div class="output_html rendered_html output_subarea ">
<h4>Latitude and Longitude of the 20 cities</h4>
</div>

</div>

<div class="output_area"><div class="prompt"></div>

<div class="output_html rendered_html output_subarea ">
<div>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Location</th>
      <th>Latitude</th>
      <th>Longitude</th>
      <th>RelLongitude</th>
      <th>RelLatitude</th>
    </tr>
    <tr>
      <th>City</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>New York</th>
      <td>40.6643, -73.9385</td>
      <td>40.66</td>
      <td>-73.94</td>
      <td>25.05</td>
      <td>4.78</td>
    </tr>
    <tr>
      <th>Los Angeles</th>
      <td>34.0194, -118.4108</td>
      <td>34.02</td>
      <td>-118.41</td>
      <td>-19.42</td>
      <td>-1.86</td>
    </tr>
    <tr>
      <th>Chicago</th>
      <td>41.8376, -87.6818</td>
      <td>41.84</td>
      <td>-87.68</td>
      <td>11.30</td>
      <td>5.96</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>Seattle</th>
      <td>47.6205, -122.3509</td>
      <td>47.62</td>
      <td>-122.35</td>
      <td>-23.37</td>
      <td>11.74</td>
    </tr>
    <tr>
      <th>Denver</th>
      <td>39.7618, -104.8806</td>
      <td>39.76</td>
      <td>-104.88</td>
      <td>-5.89</td>
      <td>3.88</td>
    </tr>
    <tr>
      <th>El Paso</th>
      <td>31.8484, -106.427</td>
      <td>31.85</td>
      <td>-106.43</td>
      <td>-7.44</td>
      <td>-4.03</td>
    </tr>
  </tbody>
</table>
<p>20 rows × 5 columns</p>
</div>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Encode">Encode<a class="anchor-link" href="#Encode">&#182;</a></h2><p>Encode the latitude and longitude into a "space filling curve index" -- a monotonic locality preserving index that can be used to quickly lookup relative distances in 2 (or even higher) dimensions easily. See <a href="https://arxiv.org/pdf/1109.2323v2.pdf">https://arxiv.org/pdf/1109.2323v2.pdf</a> and <a href="http://www.cslab.ece.ntua.gr/twiki/pub/Collab/MultidimensionalIndexing/Alternative_Algorithm_for_Hilbert_s_Space_Filling_Curve.pdf">http://www.cslab.ece.ntua.gr/twiki/pub/Collab/MultidimensionalIndexing/Alternative_Algorithm_for_Hilbert_s_Space_Filling_Curve.pdf</a> for details.</p>
<p>Google's S2 Sphere is a generalized code that exhibits similar locality preserving traits as Hilbert space filling curve. See <a href="http://blog.christianperone.com/2015/08/googles-s2-geometry-on-the-sphere-cells-and-hilbert-curve/">http://blog.christianperone.com/2015/08/googles-s2-geometry-on-the-sphere-cells-and-hilbert-curve/</a> for a detailed explanation.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[3]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython2"><pre><span></span><span class="c1"># Encode s2 cell ids for each cities</span>
<span class="kn">import</span> <span class="nn">s2sphere</span>
<span class="kn">from</span> <span class="nn">s2sphere</span> <span class="kn">import</span> <span class="n">Angle</span><span class="p">,</span> <span class="n">CellId</span><span class="p">,</span> <span class="n">LatLng</span>

<span class="c1"># Cell ID is a number that resolves a geographic location to a unit sq-cm on the earth with only one long number</span>
<span class="n">get_cellid</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">lat</span><span class="p">,</span><span class="n">lng</span><span class="p">:</span> <span class="n">CellId</span><span class="o">.</span><span class="n">from_lat_lng</span><span class="p">(</span><span class="n">LatLng</span><span class="o">.</span><span class="n">from_degrees</span><span class="p">(</span><span class="n">lat</span><span class="p">,</span><span class="n">lng</span><span class="p">))</span><span class="o">.</span><span class="n">id</span><span class="p">()</span> <span class="k">if</span> <span class="nb">all</span><span class="p">([</span><span class="n">lat</span><span class="p">,</span><span class="n">lng</span><span class="p">])</span> <span class="k">else</span> <span class="mi">0</span>

<span class="c1"># Put the CellID in the dataframe</span>
<span class="n">interested_cities</span><span class="p">[</span><span class="s1">&#39;CellID&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">interested_cities</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
    <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">get_cellid</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="s1">&#39;RelLatitude&#39;</span><span class="p">]),</span> <span class="nb">float</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="s1">&#39;RelLongitude&#39;</span><span class="p">])),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># Make the S2 Index relative to New York</span>
<span class="n">interested_cities</span><span class="p">[</span><span class="s1">&#39;RelCellID&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">interested_cities</span><span class="p">[</span>
    <span class="s1">&#39;CellID&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">interested_cities</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="s1">&#39;New York&#39;</span><span class="p">][</span><span class="s1">&#39;CellID&#39;</span><span class="p">])</span>

<span class="c1"># Display preview</span>
<span class="n">display</span><span class="p">(</span><span class="n">interested_cities</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s1">&#39;RelCellID&#39;</span><span class="p">))</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area"><div class="prompt"></div>

<div class="output_html rendered_html output_subarea ">
<div>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Location</th>
      <th>Latitude</th>
      <th>Longitude</th>
      <th>RelLongitude</th>
      <th>RelLatitude</th>
      <th>CellID</th>
      <th>RelCellID</th>
    </tr>
    <tr>
      <th>City</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>New York</th>
      <td>40.6643, -73.9385</td>
      <td>40.66</td>
      <td>-73.94</td>
      <td>25.05</td>
      <td>4.78</td>
      <td>1673033395779129293</td>
      <td>0</td>
    </tr>
    <tr>
      <th>Philadelphia</th>
      <td>40.0094, -75.1333</td>
      <td>40.01</td>
      <td>-75.13</td>
      <td>23.85</td>
      <td>4.13</td>
      <td>1678214086752040423</td>
      <td>5180690972911130</td>
    </tr>
    <tr>
      <th>Charlotte</th>
      <td>35.2087, -80.8307</td>
      <td>35.21</td>
      <td>-80.83</td>
      <td>18.16</td>
      <td>-0.67</td>
      <td>1876166626263424565</td>
      <td>203133230484295272</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>San Diego</th>
      <td>32.8153, -117.135</td>
      <td>32.82</td>
      <td>-117.14</td>
      <td>-18.15</td>
      <td>-3.07</td>
      <td>427424719826299983</td>
      <td>1245608675952829310</td>
    </tr>
    <tr>
      <th>Phoenix</th>
      <td>33.5722, -112.088</td>
      <td>33.57</td>
      <td>-112.09</td>
      <td>-13.10</td>
      <td>-2.31</td>
      <td>397784215078795125</td>
      <td>1275249180700334168</td>
    </tr>
    <tr>
      <th>El Paso</th>
      <td>31.8484, -106.427</td>
      <td>31.85</td>
      <td>-106.43</td>
      <td>-7.44</td>
      <td>-4.03</td>
      <td>391226763282846791</td>
      <td>1281806632496282502</td>
    </tr>
  </tbody>
</table>
<p>20 rows × 7 columns</p>
</div>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Just spotting the RelCellID index values seems to suggest the farthest point to New York is Seattle and San Francisco; The CellIDs also seem to suggest that San Francisco and San Jose are very close to each other on the map.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Order">Order<a class="anchor-link" href="#Order">&#182;</a></h2><p>Let us use a very simple heuristic. Shortest distance first from current location aka Djikstra's algorithm. <a href="https://en.wikipedia.org/wiki/Dijkstra%27s_algorithmOrder">https://en.wikipedia.org/wiki/Dijkstra%27s_algorithmOrder</a> to plan the travel from New York. Since we are beginning our travel from New York, let us identify next target.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[4]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython2"><pre><span></span><span class="c1"># Compute routine to identify the next closest location from a city</span>
<span class="k">def</span> <span class="nf">get_order</span><span class="p">(</span><span class="n">interested_cities</span><span class="p">,</span> <span class="n">src_city</span><span class="p">):</span>
    <span class="c1"># Push the first cell as the initial state</span>
    <span class="n">visited</span> <span class="o">=</span> <span class="p">[</span><span class="n">src_city</span><span class="p">]</span>

    <span class="c1"># For each state, aka city, find closest city that has not been visited</span>
    <span class="k">def</span> <span class="nf">find_nearest</span><span class="p">(</span><span class="n">city</span><span class="p">):</span>
        <span class="c1"># Make the S2 Index relative to New York</span>
        <span class="n">interested_cities</span><span class="p">[</span><span class="s1">&#39;RelCellID&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">interested_cities</span><span class="p">[</span><span class="s1">&#39;CellID&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">interested_cities</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="n">city</span><span class="p">][</span><span class="s1">&#39;CellID&#39;</span><span class="p">])</span>
        <span class="c1"># Find closest city to current city where it has not already been visited</span>
        <span class="n">cities</span> <span class="o">=</span> <span class="p">[</span><span class="n">city</span> <span class="k">for</span> <span class="n">city</span> <span class="ow">in</span> <span class="n">interested_cities</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s1">&#39;RelCellID&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span> <span class="k">if</span> <span class="n">city</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">cities</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">cities</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">target_city</span> <span class="o">=</span> <span class="n">cities</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">visited</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">target_city</span><span class="p">)</span>
            <span class="c1"># Recursively call until all cities have been visited</span>
            <span class="k">return</span> <span class="n">find_nearest</span><span class="p">(</span><span class="n">target_city</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">visited</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">src_city</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">visited</span>
    <span class="k">return</span> <span class="n">find_nearest</span><span class="p">(</span><span class="n">src_city</span><span class="p">)</span>

<span class="c1"># Compute plan</span>
<span class="n">plan</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">get_order</span><span class="p">(</span><span class="n">interested_cities</span><span class="p">,</span> <span class="s1">&#39;New York&#39;</span><span class="p">),</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;City&quot;</span><span class="p">])</span>

<span class="c1"># Form a ordered series of records</span>
<span class="n">plan</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">&#39;City&#39;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">drop</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="c1"># Assign a order of the visit</span>
<span class="n">plan</span><span class="p">[</span><span class="s1">&#39;order&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">plan</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span><span class="p">)]</span>

<span class="c1"># Display the plan</span>
<span class="n">pd_display</span><span class="p">(</span><span class="n">plan</span><span class="p">,</span> <span class="s2">&quot;Order in which we may visit the cities starting from New York&quot;</span><span class="p">)</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area"><div class="prompt"></div>

<div class="output_html rendered_html output_subarea ">
<h4>Order in which we may visit the cities starting from New York</h4>
</div>

</div>

<div class="output_area"><div class="prompt"></div>

<div class="output_html rendered_html output_subarea ">
<div>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>order</th>
    </tr>
    <tr>
      <th>City</th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>New York</th>
      <td>0</td>
    </tr>
    <tr>
      <th>Philadelphia</th>
      <td>1</td>
    </tr>
    <tr>
      <th>Charlotte</th>
      <td>2</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
    </tr>
    <tr>
      <th>Phoenix</th>
      <td>18</td>
    </tr>
    <tr>
      <th>El Paso</th>
      <td>19</td>
    </tr>
    <tr>
      <th>New York</th>
      <td>20</td>
    </tr>
  </tbody>
</table>
<p>21 rows × 1 columns</p>
</div>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Plotting-Route">Plotting Route<a class="anchor-link" href="#Plotting-Route">&#182;</a></h2><p>Now that we have an ordered route, let us bring back the latitude and longitude so we may plot the route.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[5]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython2"><pre><span></span><span class="c1"># Join with original records for lat and longitude information</span>
<span class="n">city_coordinates</span> <span class="o">=</span> <span class="n">plan</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">interested_cities</span><span class="p">)</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s1">&#39;order&#39;</span><span class="p">)</span>
</pre></div>

</div>
</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Plot.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[6]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython2"><pre><span></span><span class="c1"># Plot the map</span>
<span class="kn">import</span> <span class="nn">folium</span>
<span class="n">folium</span><span class="o">.</span><span class="n">initialize_notebook</span><span class="p">()</span>

<span class="c1"># Initialize a map</span>
<span class="n">geomap</span> <span class="o">=</span> <span class="n">folium</span><span class="o">.</span><span class="n">Map</span><span class="p">(</span><span class="n">zoom_start</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
                    <span class="n">max_zoom</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span>
                    <span class="n">min_zoom</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
                    <span class="n">location</span><span class="o">=</span><span class="p">[</span>
                        <span class="n">city_coordinates</span><span class="p">[</span><span class="s1">&#39;Latitude&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">(),</span>
                        <span class="n">city_coordinates</span><span class="p">[</span><span class="s1">&#39;Longitude&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
                    <span class="p">])</span>  <span class="c1"># US map</span>

<span class="c1"># Create lines</span>
<span class="n">lines</span> <span class="o">=</span> <span class="n">folium</span><span class="o">.</span><span class="n">PolyLine</span><span class="p">(</span>
    <span class="n">locations</span><span class="o">=</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">,</span>
                  <span class="n">city_coordinates</span><span class="p">[[</span><span class="s1">&#39;Latitude&#39;</span><span class="p">,</span> <span class="s1">&#39;Longitude&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span><span class="p">),</span>
    <span class="n">color</span><span class="o">=</span><span class="s1">&#39;blue&#39;</span><span class="p">,</span>
    <span class="n">weight</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
    <span class="n">opacity</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>

<span class="c1"># Create markers</span>
<span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">city</span> <span class="ow">in</span> <span class="n">city_coordinates</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
    <span class="n">marker</span> <span class="o">=</span> <span class="n">folium</span><span class="o">.</span><span class="n">CircleMarker</span><span class="p">(</span>
        <span class="n">radius</span><span class="o">=</span><span class="mi">100000</span><span class="p">,</span>
        <span class="n">fill_color</span><span class="o">=</span><span class="s1">&#39;#</span><span class="si">%02x%02x%02x</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="nb">tuple</span><span class="p">(</span>
            <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="mi">255</span><span class="p">),</span>
                <span class="n">sns</span><span class="o">.</span><span class="n">color_palette</span><span class="p">(</span><span class="s2">&quot;Blues&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">city_coordinates</span><span class="p">))[</span><span class="n">city</span><span class="p">[</span>
                    <span class="s1">&#39;order&#39;</span><span class="p">]])),</span>
        <span class="n">color</span><span class="o">=</span><span class="s1">&#39;blue&#39;</span><span class="p">,</span>
        <span class="n">location</span><span class="o">=</span><span class="p">[</span><span class="n">city</span><span class="o">.</span><span class="n">Latitude</span><span class="p">,</span> <span class="n">city</span><span class="o">.</span><span class="n">Longitude</span><span class="p">],</span>
        <span class="n">popup</span><span class="o">=</span><span class="s2">&quot;{0} visited {1}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">city</span><span class="p">[</span><span class="s1">&#39;order&#39;</span><span class="p">]))</span><span class="o">.</span><span class="n">add_to</span><span class="p">(</span><span class="n">geomap</span><span class="p">)</span>

<span class="c1"># Plot map</span>
<span class="n">geomap</span><span class="o">.</span><span class="n">add_child</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>
<span class="n">geomap</span><span class="o">.</span><span class="n">fit_bounds</span><span class="p">(</span>
    <span class="p">[[</span>
        <span class="n">city_coordinates</span><span class="p">[</span><span class="s1">&#39;Latitude&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span>
        <span class="n">city_coordinates</span><span class="p">[</span><span class="s1">&#39;Longitude&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">-</span> <span class="mi">2</span>
    <span class="p">],</span> <span class="p">[</span>
        <span class="n">city_coordinates</span><span class="p">[</span><span class="s1">&#39;Latitude&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span>
        <span class="n">city_coordinates</span><span class="p">[</span><span class="s1">&#39;Longitude&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">+</span> <span class="mi">2</span>
    <span class="p">]],</span>
    <span class="n">max_zoom</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>

<span class="c1"># Render</span>
<span class="n">display</span><span class="p">(</span><span class="n">geomap</span><span class="p">)</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area"><div class="prompt"></div>

<div class="output_html rendered_html output_subarea ">
<div style="width:100%;"><div style="position:relative;width:100%;height:0;padding-bottom:60%;"><iframe src="data:text/html;base64,CiAgICAgICAgPCFET0NUWVBFIGh0bWw+CiAgICAgICAgPGhlYWQ+CiAgICAgICAgICAgIAogICAgICAgIAogICAgICAgICAgICA8bWV0YSBodHRwLWVxdWl2PSJjb250ZW50LXR5cGUiIGNvbnRlbnQ9InRleHQvaHRtbDsgY2hhcnNldD1VVEYtOCIgLz4KICAgICAgICAKICAgICAgICAgICAgCiAgICAgICAgCiAgICAgICAgICAgIDxzY3JpcHQgc3JjPSJodHRwczovL2NkbmpzLmNsb3VkZmxhcmUuY29tL2FqYXgvbGlicy9sZWFmbGV0LzAuNy4zL2xlYWZsZXQuanMiPjwvc2NyaXB0PgogICAgICAgIAogICAgICAgIAogICAgICAgIAogICAgICAgICAgICAKICAgICAgICAKICAgICAgICAgICAgPHNjcmlwdCBzcmM9Imh0dHBzOi8vYWpheC5nb29nbGVhcGlzLmNvbS9hamF4L2xpYnMvanF1ZXJ5LzEuMTEuMS9qcXVlcnkubWluLmpzIj48L3NjcmlwdD4KICAgICAgICAKICAgICAgICAKICAgICAgICAKICAgICAgICAgICAgCiAgICAgICAgCiAgICAgICAgICAgIDxzY3JpcHQgc3JjPSJodHRwczovL21heGNkbi5ib290c3RyYXBjZG4uY29tL2Jvb3RzdHJhcC8zLjIuMC9qcy9ib290c3RyYXAubWluLmpzIj48L3NjcmlwdD4KICAgICAgICAKICAgICAgICAKICAgICAgICAKICAgICAgICAgICAgCiAgICAgICAgCiAgICAgICAgICAgIDxzY3JpcHQgc3JjPSJodHRwczovL2NkbmpzLmNsb3VkZmxhcmUuY29tL2FqYXgvbGlicy9MZWFmbGV0LmF3ZXNvbWUtbWFya2Vycy8yLjAuMi9sZWFmbGV0LmF3ZXNvbWUtbWFya2Vycy5taW4uanMiPjwvc2NyaXB0PgogICAgICAgIAogICAgICAgIAogICAgICAgIAogICAgICAgICAgICAKICAgICAgICAKICAgICAgICAgICAgPHNjcmlwdCBzcmM9Imh0dHBzOi8vY2RuanMuY2xvdWRmbGFyZS5jb20vYWpheC9saWJzL2xlYWZsZXQubWFya2VyY2x1c3Rlci8wLjQuMC9sZWFmbGV0Lm1hcmtlcmNsdXN0ZXItc3JjLmpzIj48L3NjcmlwdD4KICAgICAgICAKICAgICAgICAKICAgICAgICAKICAgICAgICAgICAgCiAgICAgICAgCiAgICAgICAgICAgIDxzY3JpcHQgc3JjPSJodHRwczovL2NkbmpzLmNsb3VkZmxhcmUuY29tL2FqYXgvbGlicy9sZWFmbGV0Lm1hcmtlcmNsdXN0ZXIvMC40LjAvbGVhZmxldC5tYXJrZXJjbHVzdGVyLmpzIj48L3NjcmlwdD4KICAgICAgICAKICAgICAgICAKICAgICAgICAKICAgICAgICAgICAgCiAgICAgICAgCiAgICAgICAgICAgIDxsaW5rIHJlbD0ic3R5bGVzaGVldCIgaHJlZj0iaHR0cHM6Ly9jZG5qcy5jbG91ZGZsYXJlLmNvbS9hamF4L2xpYnMvbGVhZmxldC8wLjcuMy9sZWFmbGV0LmNzcyIgLz4KICAgICAgICAKICAgICAgICAKICAgICAgICAKICAgICAgICAgICAgCiAgICAgICAgCiAgICAgICAgICAgIDxsaW5rIHJlbD0ic3R5bGVzaGVldCIgaHJlZj0iaHR0cHM6Ly9tYXhjZG4uYm9vdHN0cmFwY2RuLmNvbS9ib290c3RyYXAvMy4yLjAvY3NzL2Jvb3RzdHJhcC5taW4uY3NzIiAvPgogICAgICAgIAogICAgICAgIAogICAgICAgIAogICAgICAgICAgICAKICAgICAgICAKICAgICAgICAgICAgPGxpbmsgcmVsPSJzdHlsZXNoZWV0IiBocmVmPSJodHRwczovL21heGNkbi5ib290c3RyYXBjZG4uY29tL2Jvb3RzdHJhcC8zLjIuMC9jc3MvYm9vdHN0cmFwLXRoZW1lLm1pbi5jc3MiIC8+CiAgICAgICAgCiAgICAgICAgCiAgICAgICAgCiAgICAgICAgICAgIAogICAgICAgIAogICAgICAgICAgICA8bGluayByZWw9InN0eWxlc2hlZXQiIGhyZWY9Imh0dHBzOi8vbWF4Y2RuLmJvb3RzdHJhcGNkbi5jb20vZm9udC1hd2Vzb21lLzQuMS4wL2Nzcy9mb250LWF3ZXNvbWUubWluLmNzcyIgLz4KICAgICAgICAKICAgICAgICAKICAgICAgICAKICAgICAgICAgICAgCiAgICAgICAgCiAgICAgICAgICAgIDxsaW5rIHJlbD0ic3R5bGVzaGVldCIgaHJlZj0iaHR0cHM6Ly9jZG5qcy5jbG91ZGZsYXJlLmNvbS9hamF4L2xpYnMvTGVhZmxldC5hd2Vzb21lLW1hcmtlcnMvMi4wLjIvbGVhZmxldC5hd2Vzb21lLW1hcmtlcnMuY3NzIiAvPgogICAgICAgIAogICAgICAgIAogICAgICAgIAogICAgICAgICAgICAKICAgICAgICAKICAgICAgICAgICAgPGxpbmsgcmVsPSJzdHlsZXNoZWV0IiBocmVmPSJodHRwczovL2NkbmpzLmNsb3VkZmxhcmUuY29tL2FqYXgvbGlicy9sZWFmbGV0Lm1hcmtlcmNsdXN0ZXIvMC40LjAvTWFya2VyQ2x1c3Rlci5EZWZhdWx0LmNzcyIgLz4KICAgICAgICAKICAgICAgICAKICAgICAgICAKICAgICAgICAgICAgCiAgICAgICAgCiAgICAgICAgICAgIDxsaW5rIHJlbD0ic3R5bGVzaGVldCIgaHJlZj0iaHR0cHM6Ly9jZG5qcy5jbG91ZGZsYXJlLmNvbS9hamF4L2xpYnMvbGVhZmxldC5tYXJrZXJjbHVzdGVyLzAuNC4wL01hcmtlckNsdXN0ZXIuY3NzIiAvPgogICAgICAgIAogICAgICAgIAogICAgICAgIAogICAgICAgICAgICAKICAgICAgICAKICAgICAgICAgICAgPGxpbmsgcmVsPSJzdHlsZXNoZWV0IiBocmVmPSJodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vcHl0aG9uLXZpc3VhbGl6YXRpb24vZm9saXVtL21hc3Rlci9mb2xpdW0vdGVtcGxhdGVzL2xlYWZsZXQuYXdlc29tZS5yb3RhdGUuY3NzIiAvPgogICAgICAgIAogICAgICAgIAogICAgICAgIAogICAgICAgICAgICAKICAgICAgICAgICAgPHN0eWxlPgoKICAgICAgICAgICAgaHRtbCwgYm9keSB7CiAgICAgICAgICAgICAgICB3aWR0aDogMTAwJTsKICAgICAgICAgICAgICAgIGhlaWdodDogMTAwJTsKICAgICAgICAgICAgICAgIG1hcmdpbjogMDsKICAgICAgICAgICAgICAgIHBhZGRpbmc6IDA7CiAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAjbWFwIHsKICAgICAgICAgICAgICAgIHBvc2l0aW9uOmFic29sdXRlOwogICAgICAgICAgICAgICAgdG9wOjA7CiAgICAgICAgICAgICAgICBib3R0b206MDsKICAgICAgICAgICAgICAgIHJpZ2h0OjA7CiAgICAgICAgICAgICAgICBsZWZ0OjA7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIDwvc3R5bGU+CiAgICAgICAgICAgIAogICAgICAgIAogICAgICAgICAgICAKICAgICAgICAgICAgPHN0eWxlPiAjbWFwX2IzNjk4YWE4MTJiNjQ3NDI5Njc4Yzg5YTdkNTE0MzIxIHsKICAgICAgICAgICAgICAgIHBvc2l0aW9uIDogcmVsYXRpdmU7CiAgICAgICAgICAgICAgICB3aWR0aCA6IDEwMC4wJTsKICAgICAgICAgICAgICAgIGhlaWdodDogMTAwLjAlOwogICAgICAgICAgICAgICAgbGVmdDogMC4wJTsKICAgICAgICAgICAgICAgIHRvcDogMC4wJTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgPC9zdHlsZT4KICAgICAgICAKICAgICAgICAKICAgICAgICAKICAgICAgICA8L2hlYWQ+CiAgICAgICAgPGJvZHk+CiAgICAgICAgICAgIAogICAgICAgIAogICAgICAgICAgICAKICAgICAgICAgICAgPGRpdiBjbGFzcz0iZm9saXVtLW1hcCIgaWQ9Im1hcF9iMzY5OGFhODEyYjY0NzQyOTY3OGM4OWE3ZDUxNDMyMSIgPjwvZGl2PgogICAgICAgIAogICAgICAgIAogICAgICAgIAogICAgICAgIDwvYm9keT4KICAgICAgICA8c2NyaXB0PgogICAgICAgICAgICAKICAgICAgICAKICAgICAgICAgICAgCgogICAgICAgICAgICB2YXIgc291dGhXZXN0ID0gTC5sYXRMbmcoLTkwLCAtMTgwKTsKICAgICAgICAgICAgdmFyIG5vcnRoRWFzdCA9IEwubGF0TG5nKDkwLCAxODApOwogICAgICAgICAgICB2YXIgYm91bmRzID0gTC5sYXRMbmdCb3VuZHMoc291dGhXZXN0LCBub3J0aEVhc3QpOwoKICAgICAgICAgICAgdmFyIG1hcF9iMzY5OGFhODEyYjY0NzQyOTY3OGM4OWE3ZDUxNDMyMSA9IEwubWFwKCdtYXBfYjM2OThhYTgxMmI2NDc0Mjk2NzhjODlhN2Q1MTQzMjEnLCB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZW50ZXI6WzM2LjEwOTg5MDQ3NjIsLTk3Ljc5MzE1NzE0MjldLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgem9vbTogNCwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heEJvdW5kczogYm91bmRzLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXJzOiBbXSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNyczogTC5DUlMuRVBTRzM4NTcKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgCiAgICAgICAgCiAgICAgICAgCiAgICAgICAgICAgIAogICAgICAgICAgICB2YXIgdGlsZV9sYXllcl9iZjBiYjljMzdmNWI0OWQ4YmRmN2Q0NDYwZWU5ODllMCA9IEwudGlsZUxheWVyKAogICAgICAgICAgICAgICAgJ2h0dHBzOi8ve3N9LnRpbGUub3BlbnN0cmVldG1hcC5vcmcve3p9L3t4fS97eX0ucG5nJywKICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICBtYXhab29tOiA2LAogICAgICAgICAgICAgICAgICAgIG1pblpvb206IDQsCiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRpb246ICdEYXRhIGJ5IDxhIGhyZWY9Imh0dHA6Ly9vcGVuc3RyZWV0bWFwLm9yZyI+T3BlblN0cmVldE1hcDwvYT4sIHVuZGVyIDxhIGhyZWY9Imh0dHA6Ly93d3cub3BlbnN0cmVldG1hcC5vcmcvY29weXJpZ2h0Ij5PRGJMPC9hPi4nLAogICAgICAgICAgICAgICAgICAgIGRldGVjdFJldGluYTogZmFsc2UKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF9iMzY5OGFhODEyYjY0NzQyOTY3OGM4OWE3ZDUxNDMyMSk7CgogICAgICAgIAogICAgICAgIAogICAgICAgICAgICAKCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzEwM2NjZjdjM2ZjZjRmM2RiYjNlNGFjODg1NTk2YTA4ID0gTC5jaXJjbGUoCiAgICAgICAgICAgICAgICBbNDAuNjY0MywtNzMuOTM4NV0sCiAgICAgICAgICAgICAgICAxMDAwMDAsCiAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgY29sb3I6ICdibHVlJywKICAgICAgICAgICAgICAgICAgICBmaWxsQ29sb3I6ICcjZWVmNWZjJywKICAgICAgICAgICAgICAgICAgICBmaWxsT3BhY2l0eTogMC42CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgKQogICAgICAgICAgICAgICAgLmFkZFRvKG1hcF9iMzY5OGFhODEyYjY0NzQyOTY3OGM4OWE3ZDUxNDMyMSk7CiAgICAgICAgICAgIAogICAgICAgIAogICAgICAgICAgICAKICAgICAgICAgICAgdmFyIHBvcHVwXzBmZTliOWI5MjA3OTQ5NWNhNzE0MDczNWM3NzIyNzdjID0gTC5wb3B1cCh7bWF4V2lkdGg6ICczMDAnfSk7CgogICAgICAgICAgICAKICAgICAgICAgICAgICAgIHZhciBodG1sXzlkOTZjNWM1ZGM5ODQ0NDM5YWVhMzM0ODY2M2E5MzgzID0gJCgnICAgICAgICAgPGRpdiBpZD0iaHRtbF85ZDk2YzVjNWRjOTg0NDQzOWFlYTMzNDg2NjNhOTM4MyIgICAgICAgICAgICAgICAgIHN0eWxlPSJ3aWR0aDogMTAwLjAlOyBoZWlnaHQ6IDEwMC4wJTsiPiAgICAgICAgICAgICAgICAgTmV3IFlvcmsgdmlzaXRlZCAwPC9kaXY+ICAgICAgICAgICAgICAgICAnKVswXTsKICAgICAgICAgICAgICAgIHBvcHVwXzBmZTliOWI5MjA3OTQ5NWNhNzE0MDczNWM3NzIyNzdjLnNldENvbnRlbnQoaHRtbF85ZDk2YzVjNWRjOTg0NDQzOWFlYTMzNDg2NjNhOTM4Myk7CiAgICAgICAgICAgIAoKICAgICAgICAgICAgY2lyY2xlX21hcmtlcl8xMDNjY2Y3YzNmY2Y0ZjNkYmIzZTRhYzg4NTU5NmEwOC5iaW5kUG9wdXAocG9wdXBfMGZlOWI5YjkyMDc5NDk1Y2E3MTQwNzM1Yzc3MjI3N2MpOwoKICAgICAgICAgICAgCiAgICAgICAgCiAgICAgICAgCiAgICAgICAgICAgIAoKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfM2VhZTQwNzdhYTY3NGVkZWFmNzQ1ZTlmNjEyYzFhNDEgPSBMLmNpcmNsZSgKICAgICAgICAgICAgICAgIFs0MC4wMDk0LC03NS4xMzMzXSwKICAgICAgICAgICAgICAgIDEwMDAwMCwKICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICBjb2xvcjogJ2JsdWUnLAogICAgICAgICAgICAgICAgICAgIGZpbGxDb2xvcjogJyNlNGVmZjknLAogICAgICAgICAgICAgICAgICAgIGZpbGxPcGFjaXR5OiAwLjYKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICApCiAgICAgICAgICAgICAgICAuYWRkVG8obWFwX2IzNjk4YWE4MTJiNjQ3NDI5Njc4Yzg5YTdkNTE0MzIxKTsKICAgICAgICAgICAgCiAgICAgICAgCiAgICAgICAgICAgIAogICAgICAgICAgICB2YXIgcG9wdXBfMWI1NGVkZjgyZDQ4NGFjY2I2MDNkNzk2OWI2NmUxZTQgPSBMLnBvcHVwKHttYXhXaWR0aDogJzMwMCd9KTsKCiAgICAgICAgICAgIAogICAgICAgICAgICAgICAgdmFyIGh0bWxfMzU1ZGJhM2FhMjQzNGM5M2ExMDNiZDVhNjUxNWQxMmQgPSAkKCcgICAgICAgICA8ZGl2IGlkPSJodG1sXzM1NWRiYTNhYTI0MzRjOTNhMTAzYmQ1YTY1MTVkMTJkIiAgICAgICAgICAgICAgICAgc3R5bGU9IndpZHRoOiAxMDAuMCU7IGhlaWdodDogMTAwLjAlOyI+ICAgICAgICAgICAgICAgICBQaGlsYWRlbHBoaWEgdmlzaXRlZCAxPC9kaXY+ICAgICAgICAgICAgICAgICAnKVswXTsKICAgICAgICAgICAgICAgIHBvcHVwXzFiNTRlZGY4MmQ0ODRhY2NiNjAzZDc5NjliNjZlMWU0LnNldENvbnRlbnQoaHRtbF8zNTVkYmEzYWEyNDM0YzkzYTEwM2JkNWE2NTE1ZDEyZCk7CiAgICAgICAgICAgIAoKICAgICAgICAgICAgY2lyY2xlX21hcmtlcl8zZWFlNDA3N2FhNjc0ZWRlYWY3NDVlOWY2MTJjMWE0MS5iaW5kUG9wdXAocG9wdXBfMWI1NGVkZjgyZDQ4NGFjY2I2MDNkNzk2OWI2NmUxZTQpOwoKICAgICAgICAgICAgCiAgICAgICAgCiAgICAgICAgCiAgICAgICAgICAgIAoKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfZjgxNjI4OTQ2ZDYwNDljMGE2MmFlYWIxYzJiZDJlZTQgPSBMLmNpcmNsZSgKICAgICAgICAgICAgICAgIFszNS4yMDg3LC04MC44MzA3XSwKICAgICAgICAgICAgICAgIDEwMDAwMCwKICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICBjb2xvcjogJ2JsdWUnLAogICAgICAgICAgICAgICAgICAgIGZpbGxDb2xvcjogJyNkY2U5ZjYnLAogICAgICAgICAgICAgICAgICAgIGZpbGxPcGFjaXR5OiAwLjYKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICApCiAgICAgICAgICAgICAgICAuYWRkVG8obWFwX2IzNjk4YWE4MTJiNjQ3NDI5Njc4Yzg5YTdkNTE0MzIxKTsKICAgICAgICAgICAgCiAgICAgICAgCiAgICAgICAgICAgIAogICAgICAgICAgICB2YXIgcG9wdXBfY2EzMzI5ZjNmYzNhNDlhMjhjNjMwODJhMjNiNDZhMGEgPSBMLnBvcHVwKHttYXhXaWR0aDogJzMwMCd9KTsKCiAgICAgICAgICAgIAogICAgICAgICAgICAgICAgdmFyIGh0bWxfMWU1OTJhMmNjYjE0NDQyMWI5OTczNDI1Yzc2NGI2OWMgPSAkKCcgICAgICAgICA8ZGl2IGlkPSJodG1sXzFlNTkyYTJjY2IxNDQ0MjFiOTk3MzQyNWM3NjRiNjljIiAgICAgICAgICAgICAgICAgc3R5bGU9IndpZHRoOiAxMDAuMCU7IGhlaWdodDogMTAwLjAlOyI+ICAgICAgICAgICAgICAgICBDaGFybG90dGUgdmlzaXRlZCAyPC9kaXY+ICAgICAgICAgICAgICAgICAnKVswXTsKICAgICAgICAgICAgICAgIHBvcHVwX2NhMzMyOWYzZmMzYTQ5YTI4YzYzMDgyYTIzYjQ2YTBhLnNldENvbnRlbnQoaHRtbF8xZTU5MmEyY2NiMTQ0NDIxYjk5NzM0MjVjNzY0YjY5Yyk7CiAgICAgICAgICAgIAoKICAgICAgICAgICAgY2lyY2xlX21hcmtlcl9mODE2Mjg5NDZkNjA0OWMwYTYyYWVhYjFjMmJkMmVlNC5iaW5kUG9wdXAocG9wdXBfY2EzMzI5ZjNmYzNhNDlhMjhjNjMwODJhMjNiNDZhMGEpOwoKICAgICAgICAgICAgCiAgICAgICAgCiAgICAgICAgCiAgICAgICAgICAgIAoKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfZGZjZGI5MzJjMzBmNDJhYjg1ZjcyNTkwZjljODY2MzUgPSBMLmNpcmNsZSgKICAgICAgICAgICAgICAgIFszMC4zMzcsLTgxLjY2MTNdLAogICAgICAgICAgICAgICAgMTAwMDAwLAogICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgIGNvbG9yOiAnYmx1ZScsCiAgICAgICAgICAgICAgICAgICAgZmlsbENvbG9yOiAnI2QzZTNmMycsCiAgICAgICAgICAgICAgICAgICAgZmlsbE9wYWNpdHk6IDAuNgogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICkKICAgICAgICAgICAgICAgIC5hZGRUbyhtYXBfYjM2OThhYTgxMmI2NDc0Mjk2NzhjODlhN2Q1MTQzMjEpOwogICAgICAgICAgICAKICAgICAgICAKICAgICAgICAgICAgCiAgICAgICAgICAgIHZhciBwb3B1cF9kZGJjNGIxYzc3MWU0ODlkOWEzY2Y4OTQ5NWU4YWI0NyA9IEwucG9wdXAoe21heFdpZHRoOiAnMzAwJ30pOwoKICAgICAgICAgICAgCiAgICAgICAgICAgICAgICB2YXIgaHRtbF9kYTM4ZTQyNzZhNjM0MmUwYTdhNDUxMjhkNDJjMGI1OSA9ICQoJyAgICAgICAgIDxkaXYgaWQ9Imh0bWxfZGEzOGU0Mjc2YTYzNDJlMGE3YTQ1MTI4ZDQyYzBiNTkiICAgICAgICAgICAgICAgICBzdHlsZT0id2lkdGg6IDEwMC4wJTsgaGVpZ2h0OiAxMDAuMCU7Ij4gICAgICAgICAgICAgICAgIEphY2tzb252aWxsZSB2aXNpdGVkIDM8L2Rpdj4gICAgICAgICAgICAgICAgICcpWzBdOwogICAgICAgICAgICAgICAgcG9wdXBfZGRiYzRiMWM3NzFlNDg5ZDlhM2NmODk0OTVlOGFiNDcuc2V0Q29udGVudChodG1sX2RhMzhlNDI3NmE2MzQyZTBhN2E0NTEyOGQ0MmMwYjU5KTsKICAgICAgICAgICAgCgogICAgICAgICAgICBjaXJjbGVfbWFya2VyX2RmY2RiOTMyYzMwZjQyYWI4NWY3MjU5MGY5Yzg2NjM1LmJpbmRQb3B1cChwb3B1cF9kZGJjNGIxYzc3MWU0ODlkOWEzY2Y4OTQ5NWU4YWI0Nyk7CgogICAgICAgICAgICAKICAgICAgICAKICAgICAgICAKICAgICAgICAgICAgCgogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9hYWYwYjhmMTFmYTI0Nzk2OTM5ZWM4MzhhMDk3M2M5MiA9IEwuY2lyY2xlKAogICAgICAgICAgICAgICAgWzMyLjc3NTcsLTk2Ljc5NjddLAogICAgICAgICAgICAgICAgMTAwMDAwLAogICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgIGNvbG9yOiAnYmx1ZScsCiAgICAgICAgICAgICAgICAgICAgZmlsbENvbG9yOiAnI2NhZGRmMCcsCiAgICAgICAgICAgICAgICAgICAgZmlsbE9wYWNpdHk6IDAuNgogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICkKICAgICAgICAgICAgICAgIC5hZGRUbyhtYXBfYjM2OThhYTgxMmI2NDc0Mjk2NzhjODlhN2Q1MTQzMjEpOwogICAgICAgICAgICAKICAgICAgICAKICAgICAgICAgICAgCiAgICAgICAgICAgIHZhciBwb3B1cF8wOWRlZDY3NGRjNjA0MzYwOGE3ZjFhNWY5OGIwZWI5ZCA9IEwucG9wdXAoe21heFdpZHRoOiAnMzAwJ30pOwoKICAgICAgICAgICAgCiAgICAgICAgICAgICAgICB2YXIgaHRtbF9hNThkYTIwMmUzYzc0ZGYyYjkwMTZlMTA5YTE4ZjMzNCA9ICQoJyAgICAgICAgIDxkaXYgaWQ9Imh0bWxfYTU4ZGEyMDJlM2M3NGRmMmI5MDE2ZTEwOWExOGYzMzQiICAgICAgICAgICAgICAgICBzdHlsZT0id2lkdGg6IDEwMC4wJTsgaGVpZ2h0OiAxMDAuMCU7Ij4gICAgICAgICAgICAgICAgIERhbGxhcyB2aXNpdGVkIDQ8L2Rpdj4gICAgICAgICAgICAgICAgICcpWzBdOwogICAgICAgICAgICAgICAgcG9wdXBfMDlkZWQ2NzRkYzYwNDM2MDhhN2YxYTVmOThiMGViOWQuc2V0Q29udGVudChodG1sX2E1OGRhMjAyZTNjNzRkZjJiOTAxNmUxMDlhMThmMzM0KTsKICAgICAgICAgICAgCgogICAgICAgICAgICBjaXJjbGVfbWFya2VyX2FhZjBiOGYxMWZhMjQ3OTY5MzllYzgzOGEwOTczYzkyLmJpbmRQb3B1cChwb3B1cF8wOWRlZDY3NGRjNjA0MzYwOGE3ZjFhNWY5OGIwZWI5ZCk7CgogICAgICAgICAgICAKICAgICAgICAKICAgICAgICAKICAgICAgICAgICAgCgogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8zNjgyOGFhN2ViZGY0NjBhYjM2YmNjYTg3OWE3NzVmMiA9IEwuY2lyY2xlKAogICAgICAgICAgICAgICAgWzMyLjc3OTUsLTk3LjM0NjNdLAogICAgICAgICAgICAgICAgMTAwMDAwLAogICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgIGNvbG9yOiAnYmx1ZScsCiAgICAgICAgICAgICAgICAgICAgZmlsbENvbG9yOiAnI2JmZDhlYycsCiAgICAgICAgICAgICAgICAgICAgZmlsbE9wYWNpdHk6IDAuNgogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICkKICAgICAgICAgICAgICAgIC5hZGRUbyhtYXBfYjM2OThhYTgxMmI2NDc0Mjk2NzhjODlhN2Q1MTQzMjEpOwogICAgICAgICAgICAKICAgICAgICAKICAgICAgICAgICAgCiAgICAgICAgICAgIHZhciBwb3B1cF85N2VlZDFkNjAxZDQ0ZWM0YjhiNzQ1MThmYTRhZWUxNCA9IEwucG9wdXAoe21heFdpZHRoOiAnMzAwJ30pOwoKICAgICAgICAgICAgCiAgICAgICAgICAgICAgICB2YXIgaHRtbF9lNWZiN2I3Y2FjMzE0Yzc3ODBjNTA5OTY0YTkyNDM2MCA9ICQoJyAgICAgICAgIDxkaXYgaWQ9Imh0bWxfZTVmYjdiN2NhYzMxNGM3NzgwYzUwOTk2NGE5MjQzNjAiICAgICAgICAgICAgICAgICBzdHlsZT0id2lkdGg6IDEwMC4wJTsgaGVpZ2h0OiAxMDAuMCU7Ij4gICAgICAgICAgICAgICAgIEZvcnQgV29ydGggdmlzaXRlZCA1PC9kaXY+ICAgICAgICAgICAgICAgICAnKVswXTsKICAgICAgICAgICAgICAgIHBvcHVwXzk3ZWVkMWQ2MDFkNDRlYzRiOGI3NDUxOGZhNGFlZTE0LnNldENvbnRlbnQoaHRtbF9lNWZiN2I3Y2FjMzE0Yzc3ODBjNTA5OTY0YTkyNDM2MCk7CiAgICAgICAgICAgIAoKICAgICAgICAgICAgY2lyY2xlX21hcmtlcl8zNjgyOGFhN2ViZGY0NjBhYjM2YmNjYTg3OWE3NzVmMi5iaW5kUG9wdXAocG9wdXBfOTdlZWQxZDYwMWQ0NGVjNGI4Yjc0NTE4ZmE0YWVlMTQpOwoKICAgICAgICAgICAgCiAgICAgICAgCiAgICAgICAgCiAgICAgICAgICAgIAoKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMDA0MTI0ZmQ1NDA0NGU3MjljMDM0YjMwZWY0ZjMzMGEgPSBMLmNpcmNsZSgKICAgICAgICAgICAgICAgIFsyOS43ODA1LC05NS4zODYzXSwKICAgICAgICAgICAgICAgIDEwMDAwMCwKICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICBjb2xvcjogJ2JsdWUnLAogICAgICAgICAgICAgICAgICAgIGZpbGxDb2xvcjogJyNiMGQxZTcnLAogICAgICAgICAgICAgICAgICAgIGZpbGxPcGFjaXR5OiAwLjYKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICApCiAgICAgICAgICAgICAgICAuYWRkVG8obWFwX2IzNjk4YWE4MTJiNjQ3NDI5Njc4Yzg5YTdkNTE0MzIxKTsKICAgICAgICAgICAgCiAgICAgICAgCiAgICAgICAgICAgIAogICAgICAgICAgICB2YXIgcG9wdXBfM2JkMTdkNTQ0ZDY3NGRjMTg5NTk3ZmVmZmVlNDg4MzcgPSBMLnBvcHVwKHttYXhXaWR0aDogJzMwMCd9KTsKCiAgICAgICAgICAgIAogICAgICAgICAgICAgICAgdmFyIGh0bWxfNWJhODE4MTQ3ODExNDQ3ZWIxNWM3ZjE2MDk2YjdlMWMgPSAkKCcgICAgICAgICA8ZGl2IGlkPSJodG1sXzViYTgxODE0NzgxMTQ0N2ViMTVjN2YxNjA5NmI3ZTFjIiAgICAgICAgICAgICAgICAgc3R5bGU9IndpZHRoOiAxMDAuMCU7IGhlaWdodDogMTAwLjAlOyI+ICAgICAgICAgICAgICAgICBIb3VzdG9uIHZpc2l0ZWQgNjwvZGl2PiAgICAgICAgICAgICAgICAgJylbMF07CiAgICAgICAgICAgICAgICBwb3B1cF8zYmQxN2Q1NDRkNjc0ZGMxODk1OTdmZWZmZWU0ODgzNy5zZXRDb250ZW50KGh0bWxfNWJhODE4MTQ3ODExNDQ3ZWIxNWM3ZjE2MDk2YjdlMWMpOwogICAgICAgICAgICAKCiAgICAgICAgICAgIGNpcmNsZV9tYXJrZXJfMDA0MTI0ZmQ1NDA0NGU3MjljMDM0YjMwZWY0ZjMzMGEuYmluZFBvcHVwKHBvcHVwXzNiZDE3ZDU0NGQ2NzRkYzE4OTU5N2ZlZmZlZTQ4ODM3KTsKCiAgICAgICAgICAgIAogICAgICAgIAogICAgICAgIAogICAgICAgICAgICAKCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzNmYjA0OGQ1MjZlNDQ4ZDg4YzQ5ZmIyMDg4NTZjOTkyID0gTC5jaXJjbGUoCiAgICAgICAgICAgICAgICBbMzAuMzA3MiwtOTcuNzU2XSwKICAgICAgICAgICAgICAgIDEwMDAwMCwKICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICBjb2xvcjogJ2JsdWUnLAogICAgICAgICAgICAgICAgICAgIGZpbGxDb2xvcjogJyNhMWNiZTInLAogICAgICAgICAgICAgICAgICAgIGZpbGxPcGFjaXR5OiAwLjYKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICApCiAgICAgICAgICAgICAgICAuYWRkVG8obWFwX2IzNjk4YWE4MTJiNjQ3NDI5Njc4Yzg5YTdkNTE0MzIxKTsKICAgICAgICAgICAgCiAgICAgICAgCiAgICAgICAgICAgIAogICAgICAgICAgICB2YXIgcG9wdXBfMGY5NjYzYmQ5NTc1NDc4Yzk3MzVkNDgxNGQxN2E0Y2UgPSBMLnBvcHVwKHttYXhXaWR0aDogJzMwMCd9KTsKCiAgICAgICAgICAgIAogICAgICAgICAgICAgICAgdmFyIGh0bWxfZGM3MTNlYjk1NmViNGRjYmIwMDI4YjZiMmY3ODVhYWYgPSAkKCcgICAgICAgICA8ZGl2IGlkPSJodG1sX2RjNzEzZWI5NTZlYjRkY2JiMDAyOGI2YjJmNzg1YWFmIiAgICAgICAgICAgICAgICAgc3R5bGU9IndpZHRoOiAxMDAuMCU7IGhlaWdodDogMTAwLjAlOyI+ICAgICAgICAgICAgICAgICBBdXN0aW4gdmlzaXRlZCA3PC9kaXY+ICAgICAgICAgICAgICAgICAnKVswXTsKICAgICAgICAgICAgICAgIHBvcHVwXzBmOTY2M2JkOTU3NTQ3OGM5NzM1ZDQ4MTRkMTdhNGNlLnNldENvbnRlbnQoaHRtbF9kYzcxM2ViOTU2ZWI0ZGNiYjAwMjhiNmIyZjc4NWFhZik7CiAgICAgICAgICAgIAoKICAgICAgICAgICAgY2lyY2xlX21hcmtlcl8zZmIwNDhkNTI2ZTQ0OGQ4OGM0OWZiMjA4ODU2Yzk5Mi5iaW5kUG9wdXAocG9wdXBfMGY5NjYzYmQ5NTc1NDc4Yzk3MzVkNDgxNGQxN2E0Y2UpOwoKICAgICAgICAgICAgCiAgICAgICAgCiAgICAgICAgCiAgICAgICAgICAgIAoKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfZTIwOWFlMmJiMzBiNGVlYWJmZjVmMzY2MzdlYjBiNmYgPSBMLmNpcmNsZSgKICAgICAgICAgICAgICAgIFsyOS40NzI0LC05OC41MjUxXSwKICAgICAgICAgICAgICAgIDEwMDAwMCwKICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICBjb2xvcjogJ2JsdWUnLAogICAgICAgICAgICAgICAgICAgIGZpbGxDb2xvcjogJyM5MGMyZGUnLAogICAgICAgICAgICAgICAgICAgIGZpbGxPcGFjaXR5OiAwLjYKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICApCiAgICAgICAgICAgICAgICAuYWRkVG8obWFwX2IzNjk4YWE4MTJiNjQ3NDI5Njc4Yzg5YTdkNTE0MzIxKTsKICAgICAgICAgICAgCiAgICAgICAgCiAgICAgICAgICAgIAogICAgICAgICAgICB2YXIgcG9wdXBfOGIwNmU0ZmY4YzljNDgyMzliNDRjOTA2MjhjMzg2N2MgPSBMLnBvcHVwKHttYXhXaWR0aDogJzMwMCd9KTsKCiAgICAgICAgICAgIAogICAgICAgICAgICAgICAgdmFyIGh0bWxfYmM1NDA4YmNjOGJlNDAyMWE2NTUwMzc1YjhlNmE2YmIgPSAkKCcgICAgICAgICA8ZGl2IGlkPSJodG1sX2JjNTQwOGJjYzhiZTQwMjFhNjU1MDM3NWI4ZTZhNmJiIiAgICAgICAgICAgICAgICAgc3R5bGU9IndpZHRoOiAxMDAuMCU7IGhlaWdodDogMTAwLjAlOyI+ICAgICAgICAgICAgICAgICBTYW4gQW50b25pbyB2aXNpdGVkIDg8L2Rpdj4gICAgICAgICAgICAgICAgICcpWzBdOwogICAgICAgICAgICAgICAgcG9wdXBfOGIwNmU0ZmY4YzljNDgyMzliNDRjOTA2MjhjMzg2N2Muc2V0Q29udGVudChodG1sX2JjNTQwOGJjYzhiZTQwMjFhNjU1MDM3NWI4ZTZhNmJiKTsKICAgICAgICAgICAgCgogICAgICAgICAgICBjaXJjbGVfbWFya2VyX2UyMDlhZTJiYjMwYjRlZWFiZmY1ZjM2NjM3ZWIwYjZmLmJpbmRQb3B1cChwb3B1cF84YjA2ZTRmZjhjOWM0ODIzOWI0NGM5MDYyOGMzODY3Yyk7CgogICAgICAgICAgICAKICAgICAgICAKICAgICAgICAKICAgICAgICAgICAgCgogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9hZGRmNmIzYWZkMWU0ZDJkYTMxOTg0ZDNjODljZTZkZCA9IEwuY2lyY2xlKAogICAgICAgICAgICAgICAgWzQxLjgzNzYsLTg3LjY4MThdLAogICAgICAgICAgICAgICAgMTAwMDAwLAogICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgIGNvbG9yOiAnYmx1ZScsCiAgICAgICAgICAgICAgICAgICAgZmlsbENvbG9yOiAnIzdkYjhkOScsCiAgICAgICAgICAgICAgICAgICAgZmlsbE9wYWNpdHk6IDAuNgogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICkKICAgICAgICAgICAgICAgIC5hZGRUbyhtYXBfYjM2OThhYTgxMmI2NDc0Mjk2NzhjODlhN2Q1MTQzMjEpOwogICAgICAgICAgICAKICAgICAgICAKICAgICAgICAgICAgCiAgICAgICAgICAgIHZhciBwb3B1cF84NTk2Zjk3NmUxYmM0MjAyOThlZjM5ZTNlZDE1MGExYyA9IEwucG9wdXAoe21heFdpZHRoOiAnMzAwJ30pOwoKICAgICAgICAgICAgCiAgICAgICAgICAgICAgICB2YXIgaHRtbF9hZDVlYTcyMTFlYjE0NjM4ODAzMWU4ZGViNjQ4MDE3OCA9ICQoJyAgICAgICAgIDxkaXYgaWQ9Imh0bWxfYWQ1ZWE3MjExZWIxNDYzODgwMzFlOGRlYjY0ODAxNzgiICAgICAgICAgICAgICAgICBzdHlsZT0id2lkdGg6IDEwMC4wJTsgaGVpZ2h0OiAxMDAuMCU7Ij4gICAgICAgICAgICAgICAgIENoaWNhZ28gdmlzaXRlZCA5PC9kaXY+ICAgICAgICAgICAgICAgICAnKVswXTsKICAgICAgICAgICAgICAgIHBvcHVwXzg1OTZmOTc2ZTFiYzQyMDI5OGVmMzllM2VkMTUwYTFjLnNldENvbnRlbnQoaHRtbF9hZDVlYTcyMTFlYjE0NjM4ODAzMWU4ZGViNjQ4MDE3OCk7CiAgICAgICAgICAgIAoKICAgICAgICAgICAgY2lyY2xlX21hcmtlcl9hZGRmNmIzYWZkMWU0ZDJkYTMxOTg0ZDNjODljZTZkZC5iaW5kUG9wdXAocG9wdXBfODU5NmY5NzZlMWJjNDIwMjk4ZWYzOWUzZWQxNTBhMWMpOwoKICAgICAgICAgICAgCiAgICAgICAgCiAgICAgICAgCiAgICAgICAgICAgIAoKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfNGVhYWI3ZDBhNWRlNGY2N2FhZjY1ZWZkNzlmMzljMWQgPSBMLmNpcmNsZSgKICAgICAgICAgICAgICAgIFszOS45ODQ4LC04Mi45ODVdLAogICAgICAgICAgICAgICAgMTAwMDAwLAogICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgIGNvbG9yOiAnYmx1ZScsCiAgICAgICAgICAgICAgICAgICAgZmlsbENvbG9yOiAnIzZhYWRkNScsCiAgICAgICAgICAgICAgICAgICAgZmlsbE9wYWNpdHk6IDAuNgogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICkKICAgICAgICAgICAgICAgIC5hZGRUbyhtYXBfYjM2OThhYTgxMmI2NDc0Mjk2NzhjODlhN2Q1MTQzMjEpOwogICAgICAgICAgICAKICAgICAgICAKICAgICAgICAgICAgCiAgICAgICAgICAgIHZhciBwb3B1cF8wY2RmM2Q3NzgyYWI0MDBlYjU3MTIzYzkzYTQzZDQ1OCA9IEwucG9wdXAoe21heFdpZHRoOiAnMzAwJ30pOwoKICAgICAgICAgICAgCiAgICAgICAgICAgICAgICB2YXIgaHRtbF8yZDkyZGM3N2E1YzM0ZWJlOWNjMjBmZWQyZGZmZDg5YSA9ICQoJyAgICAgICAgIDxkaXYgaWQ9Imh0bWxfMmQ5MmRjNzdhNWMzNGViZTljYzIwZmVkMmRmZmQ4OWEiICAgICAgICAgICAgICAgICBzdHlsZT0id2lkdGg6IDEwMC4wJTsgaGVpZ2h0OiAxMDAuMCU7Ij4gICAgICAgICAgICAgICAgIENvbHVtYnVzIHZpc2l0ZWQgMTA8L2Rpdj4gICAgICAgICAgICAgICAgICcpWzBdOwogICAgICAgICAgICAgICAgcG9wdXBfMGNkZjNkNzc4MmFiNDAwZWI1NzEyM2M5M2E0M2Q0NTguc2V0Q29udGVudChodG1sXzJkOTJkYzc3YTVjMzRlYmU5Y2MyMGZlZDJkZmZkODlhKTsKICAgICAgICAgICAgCgogICAgICAgICAgICBjaXJjbGVfbWFya2VyXzRlYWFiN2QwYTVkZTRmNjdhYWY2NWVmZDc5ZjM5YzFkLmJpbmRQb3B1cChwb3B1cF8wY2RmM2Q3NzgyYWI0MDBlYjU3MTIzYzkzYTQzZDQ1OCk7CgogICAgICAgICAgICAKICAgICAgICAKICAgICAgICAKICAgICAgICAgICAgCgogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8yOTJhYTIzMjUzYmI0ODliOGVhM2QwZDIyOGQzMDc1MCA9IEwuY2lyY2xlKAogICAgICAgICAgICAgICAgWzM5Ljc3NjcsLTg2LjE0NTldLAogICAgICAgICAgICAgICAgMTAwMDAwLAogICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgIGNvbG9yOiAnYmx1ZScsCiAgICAgICAgICAgICAgICAgICAgZmlsbENvbG9yOiAnIzVjYTNkMCcsCiAgICAgICAgICAgICAgICAgICAgZmlsbE9wYWNpdHk6IDAuNgogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICkKICAgICAgICAgICAgICAgIC5hZGRUbyhtYXBfYjM2OThhYTgxMmI2NDc0Mjk2NzhjODlhN2Q1MTQzMjEpOwogICAgICAgICAgICAKICAgICAgICAKICAgICAgICAgICAgCiAgICAgICAgICAgIHZhciBwb3B1cF9hYTgyNjc4MmM4OTk0NmY5ODAzYzcxZWVkNjhlMzc5NiA9IEwucG9wdXAoe21heFdpZHRoOiAnMzAwJ30pOwoKICAgICAgICAgICAgCiAgICAgICAgICAgICAgICB2YXIgaHRtbF82YzhjYTE3MWJhNmI0ZDFhYmZiNDEyMjk5YjlhZWU2ZCA9ICQoJyAgICAgICAgIDxkaXYgaWQ9Imh0bWxfNmM4Y2ExNzFiYTZiNGQxYWJmYjQxMjI5OWI5YWVlNmQiICAgICAgICAgICAgICAgICBzdHlsZT0id2lkdGg6IDEwMC4wJTsgaGVpZ2h0OiAxMDAuMCU7Ij4gICAgICAgICAgICAgICAgIEluZGlhbmFwb2xpcyB2aXNpdGVkIDExPC9kaXY+ICAgICAgICAgICAgICAgICAnKVswXTsKICAgICAgICAgICAgICAgIHBvcHVwX2FhODI2NzgyYzg5OTQ2Zjk4MDNjNzFlZWQ2OGUzNzk2LnNldENvbnRlbnQoaHRtbF82YzhjYTE3MWJhNmI0ZDFhYmZiNDEyMjk5YjlhZWU2ZCk7CiAgICAgICAgICAgIAoKICAgICAgICAgICAgY2lyY2xlX21hcmtlcl8yOTJhYTIzMjUzYmI0ODliOGVhM2QwZDIyOGQzMDc1MC5iaW5kUG9wdXAocG9wdXBfYWE4MjY3ODJjODk5NDZmOTgwM2M3MWVlZDY4ZTM3OTYpOwoKICAgICAgICAgICAgCiAgICAgICAgCiAgICAgICAgCiAgICAgICAgICAgIAoKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfYjVkZjc0NWI5ODNkNDM1NmFlNjhhMGUwNTdmM2ZmOGQgPSBMLmNpcmNsZSgKICAgICAgICAgICAgICAgIFszOS43NjE4LC0xMDQuODgwNl0sCiAgICAgICAgICAgICAgICAxMDAwMDAsCiAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgY29sb3I6ICdibHVlJywKICAgICAgICAgICAgICAgICAgICBmaWxsQ29sb3I6ICcjNGM5OWNhJywKICAgICAgICAgICAgICAgICAgICBmaWxsT3BhY2l0eTogMC42CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgKQogICAgICAgICAgICAgICAgLmFkZFRvKG1hcF9iMzY5OGFhODEyYjY0NzQyOTY3OGM4OWE3ZDUxNDMyMSk7CiAgICAgICAgICAgIAogICAgICAgIAogICAgICAgICAgICAKICAgICAgICAgICAgdmFyIHBvcHVwX2UyMmM4YjRkNzJkODRjZWQ4NWE4Yjk1MGIwOTFkNWZkID0gTC5wb3B1cCh7bWF4V2lkdGg6ICczMDAnfSk7CgogICAgICAgICAgICAKICAgICAgICAgICAgICAgIHZhciBodG1sXzE2ZTBjZmU1OWE1MzQ4OGY4ZWZhZjVhMDY5NzMzOWM2ID0gJCgnICAgICAgICAgPGRpdiBpZD0iaHRtbF8xNmUwY2ZlNTlhNTM0ODhmOGVmYWY1YTA2OTczMzljNiIgICAgICAgICAgICAgICAgIHN0eWxlPSJ3aWR0aDogMTAwLjAlOyBoZWlnaHQ6IDEwMC4wJTsiPiAgICAgICAgICAgICAgICAgRGVudmVyIHZpc2l0ZWQgMTI8L2Rpdj4gICAgICAgICAgICAgICAgICcpWzBdOwogICAgICAgICAgICAgICAgcG9wdXBfZTIyYzhiNGQ3MmQ4NGNlZDg1YThiOTUwYjA5MWQ1ZmQuc2V0Q29udGVudChodG1sXzE2ZTBjZmU1OWE1MzQ4OGY4ZWZhZjVhMDY5NzMzOWM2KTsKICAgICAgICAgICAgCgogICAgICAgICAgICBjaXJjbGVfbWFya2VyX2I1ZGY3NDViOTgzZDQzNTZhZTY4YTBlMDU3ZjNmZjhkLmJpbmRQb3B1cChwb3B1cF9lMjJjOGI0ZDcyZDg0Y2VkODVhOGI5NTBiMDkxZDVmZCk7CgogICAgICAgICAgICAKICAgICAgICAKICAgICAgICAKICAgICAgICAgICAgCgogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8wZDU4MDFlZWE4YjE0NjMwYTUzNTQ1NmNiODRjMjIwYSA9IEwuY2lyY2xlKAogICAgICAgICAgICAgICAgWzQ3LjYyMDUsLTEyMi4zNTA5XSwKICAgICAgICAgICAgICAgIDEwMDAwMCwKICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICBjb2xvcjogJ2JsdWUnLAogICAgICAgICAgICAgICAgICAgIGZpbGxDb2xvcjogJyMzZjhmYzQnLAogICAgICAgICAgICAgICAgICAgIGZpbGxPcGFjaXR5OiAwLjYKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICApCiAgICAgICAgICAgICAgICAuYWRkVG8obWFwX2IzNjk4YWE4MTJiNjQ3NDI5Njc4Yzg5YTdkNTE0MzIxKTsKICAgICAgICAgICAgCiAgICAgICAgCiAgICAgICAgICAgIAogICAgICAgICAgICB2YXIgcG9wdXBfNDgzNjc5NzY5OTdiNDQ3NWE1ZWZlY2EwMDAyNzI3YjIgPSBMLnBvcHVwKHttYXhXaWR0aDogJzMwMCd9KTsKCiAgICAgICAgICAgIAogICAgICAgICAgICAgICAgdmFyIGh0bWxfZTU0YWIxZDlhMzU2NGM0NDgzYTExMGU2OTlmZTQ4NjYgPSAkKCcgICAgICAgICA8ZGl2IGlkPSJodG1sX2U1NGFiMWQ5YTM1NjRjNDQ4M2ExMTBlNjk5ZmU0ODY2IiAgICAgICAgICAgICAgICAgc3R5bGU9IndpZHRoOiAxMDAuMCU7IGhlaWdodDogMTAwLjAlOyI+ICAgICAgICAgICAgICAgICBTZWF0dGxlIHZpc2l0ZWQgMTM8L2Rpdj4gICAgICAgICAgICAgICAgICcpWzBdOwogICAgICAgICAgICAgICAgcG9wdXBfNDgzNjc5NzY5OTdiNDQ3NWE1ZWZlY2EwMDAyNzI3YjIuc2V0Q29udGVudChodG1sX2U1NGFiMWQ5YTM1NjRjNDQ4M2ExMTBlNjk5ZmU0ODY2KTsKICAgICAgICAgICAgCgogICAgICAgICAgICBjaXJjbGVfbWFya2VyXzBkNTgwMWVlYThiMTQ2MzBhNTM1NDU2Y2I4NGMyMjBhLmJpbmRQb3B1cChwb3B1cF80ODM2Nzk3Njk5N2I0NDc1YTVlZmVjYTAwMDI3MjdiMik7CgogICAgICAgICAgICAKICAgICAgICAKICAgICAgICAKICAgICAgICAgICAgCgogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9kMmFmNjRjNTE2ZmM0MjdhODczNjlmZGI4ZTY2NzY3OCA9IEwuY2lyY2xlKAogICAgICAgICAgICAgICAgWzM3Ljc3NTEsLTEyMi40MTkzXSwKICAgICAgICAgICAgICAgIDEwMDAwMCwKICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICBjb2xvcjogJ2JsdWUnLAogICAgICAgICAgICAgICAgICAgIGZpbGxDb2xvcjogJyMzMjgyYmUnLAogICAgICAgICAgICAgICAgICAgIGZpbGxPcGFjaXR5OiAwLjYKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICApCiAgICAgICAgICAgICAgICAuYWRkVG8obWFwX2IzNjk4YWE4MTJiNjQ3NDI5Njc4Yzg5YTdkNTE0MzIxKTsKICAgICAgICAgICAgCiAgICAgICAgCiAgICAgICAgICAgIAogICAgICAgICAgICB2YXIgcG9wdXBfNjA0MDIzMDFjYThiNDAxYWI4YjE5YWRhMDQxOGZkYzcgPSBMLnBvcHVwKHttYXhXaWR0aDogJzMwMCd9KTsKCiAgICAgICAgICAgIAogICAgICAgICAgICAgICAgdmFyIGh0bWxfM2M1NmFkNTM5N2M4NGE1YzhiMWYxYjJiY2E3MTFkNzEgPSAkKCcgICAgICAgICA8ZGl2IGlkPSJodG1sXzNjNTZhZDUzOTdjODRhNWM4YjFmMWIyYmNhNzExZDcxIiAgICAgICAgICAgICAgICAgc3R5bGU9IndpZHRoOiAxMDAuMCU7IGhlaWdodDogMTAwLjAlOyI+ICAgICAgICAgICAgICAgICBTYW4gRnJhbmNpc2NvIHZpc2l0ZWQgMTQ8L2Rpdj4gICAgICAgICAgICAgICAgICcpWzBdOwogICAgICAgICAgICAgICAgcG9wdXBfNjA0MDIzMDFjYThiNDAxYWI4YjE5YWRhMDQxOGZkYzcuc2V0Q29udGVudChodG1sXzNjNTZhZDUzOTdjODRhNWM4YjFmMWIyYmNhNzExZDcxKTsKICAgICAgICAgICAgCgogICAgICAgICAgICBjaXJjbGVfbWFya2VyX2QyYWY2NGM1MTZmYzQyN2E4NzM2OWZkYjhlNjY3Njc4LmJpbmRQb3B1cChwb3B1cF82MDQwMjMwMWNhOGI0MDFhYjhiMTlhZGEwNDE4ZmRjNyk7CgogICAgICAgICAgICAKICAgICAgICAKICAgICAgICAKICAgICAgICAgICAgCgogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl80NmU0ZGY3MTQ3NWE0MzNlYTc0MTNjOGZiZWJlMzQ4OSA9IEwuY2lyY2xlKAogICAgICAgICAgICAgICAgWzM3LjI5NjksLTEyMS44MTkzXSwKICAgICAgICAgICAgICAgIDEwMDAwMCwKICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICBjb2xvcjogJ2JsdWUnLAogICAgICAgICAgICAgICAgICAgIGZpbGxDb2xvcjogJyMyNjc2YjcnLAogICAgICAgICAgICAgICAgICAgIGZpbGxPcGFjaXR5OiAwLjYKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICApCiAgICAgICAgICAgICAgICAuYWRkVG8obWFwX2IzNjk4YWE4MTJiNjQ3NDI5Njc4Yzg5YTdkNTE0MzIxKTsKICAgICAgICAgICAgCiAgICAgICAgCiAgICAgICAgICAgIAogICAgICAgICAgICB2YXIgcG9wdXBfZThkYjA3NDUxYWUyNDUwMGE4MDNjZDgzNzU0YjAxYTQgPSBMLnBvcHVwKHttYXhXaWR0aDogJzMwMCd9KTsKCiAgICAgICAgICAgIAogICAgICAgICAgICAgICAgdmFyIGh0bWxfOTFjNWYyYjI2MWFkNDhiNmFmZTUyOGJlNDVhMDdhMWQgPSAkKCcgICAgICAgICA8ZGl2IGlkPSJodG1sXzkxYzVmMmIyNjFhZDQ4YjZhZmU1MjhiZTQ1YTA3YTFkIiAgICAgICAgICAgICAgICAgc3R5bGU9IndpZHRoOiAxMDAuMCU7IGhlaWdodDogMTAwLjAlOyI+ICAgICAgICAgICAgICAgICBTYW4gSm9zZSB2aXNpdGVkIDE1PC9kaXY+ICAgICAgICAgICAgICAgICAnKVswXTsKICAgICAgICAgICAgICAgIHBvcHVwX2U4ZGIwNzQ1MWFlMjQ1MDBhODAzY2Q4Mzc1NGIwMWE0LnNldENvbnRlbnQoaHRtbF85MWM1ZjJiMjYxYWQ0OGI2YWZlNTI4YmU0NWEwN2ExZCk7CiAgICAgICAgICAgIAoKICAgICAgICAgICAgY2lyY2xlX21hcmtlcl80NmU0ZGY3MTQ3NWE0MzNlYTc0MTNjOGZiZWJlMzQ4OS5iaW5kUG9wdXAocG9wdXBfZThkYjA3NDUxYWUyNDUwMGE4MDNjZDgzNzU0YjAxYTQpOwoKICAgICAgICAgICAgCiAgICAgICAgCiAgICAgICAgCiAgICAgICAgICAgIAoKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfNWQ4YWI3Nzc3Mjg2NDU5OWE5Y2IwNWNlNGVlZDFmNTggPSBMLmNpcmNsZSgKICAgICAgICAgICAgICAgIFszNC4wMTk0LC0xMTguNDEwOF0sCiAgICAgICAgICAgICAgICAxMDAwMDAsCiAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgY29sb3I6ICdibHVlJywKICAgICAgICAgICAgICAgICAgICBmaWxsQ29sb3I6ICcjMWM2YmIwJywKICAgICAgICAgICAgICAgICAgICBmaWxsT3BhY2l0eTogMC42CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgKQogICAgICAgICAgICAgICAgLmFkZFRvKG1hcF9iMzY5OGFhODEyYjY0NzQyOTY3OGM4OWE3ZDUxNDMyMSk7CiAgICAgICAgICAgIAogICAgICAgIAogICAgICAgICAgICAKICAgICAgICAgICAgdmFyIHBvcHVwX2ZmNmYyYmE4NzJkNDQ0MmM4YWFkZjBlYTJhNTFmM2UxID0gTC5wb3B1cCh7bWF4V2lkdGg6ICczMDAnfSk7CgogICAgICAgICAgICAKICAgICAgICAgICAgICAgIHZhciBodG1sXzQ4MWQ2NjllMzNjNDQ3ZDBhY2FmMDQ2ZWYyMzZjMWJmID0gJCgnICAgICAgICAgPGRpdiBpZD0iaHRtbF80ODFkNjY5ZTMzYzQ0N2QwYWNhZjA0NmVmMjM2YzFiZiIgICAgICAgICAgICAgICAgIHN0eWxlPSJ3aWR0aDogMTAwLjAlOyBoZWlnaHQ6IDEwMC4wJTsiPiAgICAgICAgICAgICAgICAgTG9zIEFuZ2VsZXMgdmlzaXRlZCAxNjwvZGl2PiAgICAgICAgICAgICAgICAgJylbMF07CiAgICAgICAgICAgICAgICBwb3B1cF9mZjZmMmJhODcyZDQ0NDJjOGFhZGYwZWEyYTUxZjNlMS5zZXRDb250ZW50KGh0bWxfNDgxZDY2OWUzM2M0NDdkMGFjYWYwNDZlZjIzNmMxYmYpOwogICAgICAgICAgICAKCiAgICAgICAgICAgIGNpcmNsZV9tYXJrZXJfNWQ4YWI3Nzc3Mjg2NDU5OWE5Y2IwNWNlNGVlZDFmNTguYmluZFBvcHVwKHBvcHVwX2ZmNmYyYmE4NzJkNDQ0MmM4YWFkZjBlYTJhNTFmM2UxKTsKCiAgICAgICAgICAgIAogICAgICAgIAogICAgICAgIAogICAgICAgICAgICAKCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzE5NDhiNWEzOTQ4NjRmYTZiZmNiMjE5YzhmMDMwNTEzID0gTC5jaXJjbGUoCiAgICAgICAgICAgICAgICBbMzIuODE1MywtMTE3LjEzNV0sCiAgICAgICAgICAgICAgICAxMDAwMDAsCiAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgY29sb3I6ICdibHVlJywKICAgICAgICAgICAgICAgICAgICBmaWxsQ29sb3I6ICcjMTM1ZmE3JywKICAgICAgICAgICAgICAgICAgICBmaWxsT3BhY2l0eTogMC42CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgKQogICAgICAgICAgICAgICAgLmFkZFRvKG1hcF9iMzY5OGFhODEyYjY0NzQyOTY3OGM4OWE3ZDUxNDMyMSk7CiAgICAgICAgICAgIAogICAgICAgIAogICAgICAgICAgICAKICAgICAgICAgICAgdmFyIHBvcHVwXzFhYmViMTU3NzE0ODRmYzg4NjI5NGM5NTZiNmU5Y2JmID0gTC5wb3B1cCh7bWF4V2lkdGg6ICczMDAnfSk7CgogICAgICAgICAgICAKICAgICAgICAgICAgICAgIHZhciBodG1sXzU2ZWFjNTQxODI0ZDRhMjlhMWQ2YmI0NzdjYzc2MjYyID0gJCgnICAgICAgICAgPGRpdiBpZD0iaHRtbF81NmVhYzU0MTgyNGQ0YTI5YTFkNmJiNDc3Y2M3NjI2MiIgICAgICAgICAgICAgICAgIHN0eWxlPSJ3aWR0aDogMTAwLjAlOyBoZWlnaHQ6IDEwMC4wJTsiPiAgICAgICAgICAgICAgICAgU2FuIERpZWdvIHZpc2l0ZWQgMTc8L2Rpdj4gICAgICAgICAgICAgICAgICcpWzBdOwogICAgICAgICAgICAgICAgcG9wdXBfMWFiZWIxNTc3MTQ4NGZjODg2Mjk0Yzk1NmI2ZTljYmYuc2V0Q29udGVudChodG1sXzU2ZWFjNTQxODI0ZDRhMjlhMWQ2YmI0NzdjYzc2MjYyKTsKICAgICAgICAgICAgCgogICAgICAgICAgICBjaXJjbGVfbWFya2VyXzE5NDhiNWEzOTQ4NjRmYTZiZmNiMjE5YzhmMDMwNTEzLmJpbmRQb3B1cChwb3B1cF8xYWJlYjE1NzcxNDg0ZmM4ODYyOTRjOTU2YjZlOWNiZik7CgogICAgICAgICAgICAKICAgICAgICAKICAgICAgICAKICAgICAgICAgICAgCgogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl80MWNkNzAwMzJiNmM0NDI5YTM4ZDZlMTQ2OWY4ZTczNCA9IEwuY2lyY2xlKAogICAgICAgICAgICAgICAgWzMzLjU3MjIsLTExMi4wODhdLAogICAgICAgICAgICAgICAgMTAwMDAwLAogICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgIGNvbG9yOiAnYmx1ZScsCiAgICAgICAgICAgICAgICAgICAgZmlsbENvbG9yOiAnIzA5NTM5ZCcsCiAgICAgICAgICAgICAgICAgICAgZmlsbE9wYWNpdHk6IDAuNgogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICkKICAgICAgICAgICAgICAgIC5hZGRUbyhtYXBfYjM2OThhYTgxMmI2NDc0Mjk2NzhjODlhN2Q1MTQzMjEpOwogICAgICAgICAgICAKICAgICAgICAKICAgICAgICAgICAgCiAgICAgICAgICAgIHZhciBwb3B1cF9lMmY4MWI1N2I5NDk0ZTk5YTQwZmU0MDRiNjkxY2I0NyA9IEwucG9wdXAoe21heFdpZHRoOiAnMzAwJ30pOwoKICAgICAgICAgICAgCiAgICAgICAgICAgICAgICB2YXIgaHRtbF9iYjAwYmE4NzRkN2Y0ZDk5ODhiOGNkMGI2ZTg0MjFjOSA9ICQoJyAgICAgICAgIDxkaXYgaWQ9Imh0bWxfYmIwMGJhODc0ZDdmNGQ5OTg4YjhjZDBiNmU4NDIxYzkiICAgICAgICAgICAgICAgICBzdHlsZT0id2lkdGg6IDEwMC4wJTsgaGVpZ2h0OiAxMDAuMCU7Ij4gICAgICAgICAgICAgICAgIFBob2VuaXggdmlzaXRlZCAxODwvZGl2PiAgICAgICAgICAgICAgICAgJylbMF07CiAgICAgICAgICAgICAgICBwb3B1cF9lMmY4MWI1N2I5NDk0ZTk5YTQwZmU0MDRiNjkxY2I0Ny5zZXRDb250ZW50KGh0bWxfYmIwMGJhODc0ZDdmNGQ5OTg4YjhjZDBiNmU4NDIxYzkpOwogICAgICAgICAgICAKCiAgICAgICAgICAgIGNpcmNsZV9tYXJrZXJfNDFjZDcwMDMyYjZjNDQyOWEzOGQ2ZTE0NjlmOGU3MzQuYmluZFBvcHVwKHBvcHVwX2UyZjgxYjU3Yjk0OTRlOTlhNDBmZTQwNGI2OTFjYjQ3KTsKCiAgICAgICAgICAgIAogICAgICAgIAogICAgICAgIAogICAgICAgICAgICAKCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzVjMTJjY2NjNDJjNzRlZDE5ZmUwZDRiZTNlNjYzZDBjID0gTC5jaXJjbGUoCiAgICAgICAgICAgICAgICBbMzEuODQ4NCwtMTA2LjQyN10sCiAgICAgICAgICAgICAgICAxMDAwMDAsCiAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgY29sb3I6ICdibHVlJywKICAgICAgICAgICAgICAgICAgICBmaWxsQ29sb3I6ICcjMDg0NzhlJywKICAgICAgICAgICAgICAgICAgICBmaWxsT3BhY2l0eTogMC42CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgKQogICAgICAgICAgICAgICAgLmFkZFRvKG1hcF9iMzY5OGFhODEyYjY0NzQyOTY3OGM4OWE3ZDUxNDMyMSk7CiAgICAgICAgICAgIAogICAgICAgIAogICAgICAgICAgICAKICAgICAgICAgICAgdmFyIHBvcHVwXzhlMDU2ODYxOWNhODQ1MmZhNmE0NDUzYTRlMzBhNDAxID0gTC5wb3B1cCh7bWF4V2lkdGg6ICczMDAnfSk7CgogICAgICAgICAgICAKICAgICAgICAgICAgICAgIHZhciBodG1sX2VjOGMxNDQxYTMyMTRlZDI5YWRhMWZiMWUzMjhjOThhID0gJCgnICAgICAgICAgPGRpdiBpZD0iaHRtbF9lYzhjMTQ0MWEzMjE0ZWQyOWFkYTFmYjFlMzI4Yzk4YSIgICAgICAgICAgICAgICAgIHN0eWxlPSJ3aWR0aDogMTAwLjAlOyBoZWlnaHQ6IDEwMC4wJTsiPiAgICAgICAgICAgICAgICAgRWwgUGFzbyB2aXNpdGVkIDE5PC9kaXY+ICAgICAgICAgICAgICAgICAnKVswXTsKICAgICAgICAgICAgICAgIHBvcHVwXzhlMDU2ODYxOWNhODQ1MmZhNmE0NDUzYTRlMzBhNDAxLnNldENvbnRlbnQoaHRtbF9lYzhjMTQ0MWEzMjE0ZWQyOWFkYTFmYjFlMzI4Yzk4YSk7CiAgICAgICAgICAgIAoKICAgICAgICAgICAgY2lyY2xlX21hcmtlcl81YzEyY2NjYzQyYzc0ZWQxOWZlMGQ0YmUzZTY2M2QwYy5iaW5kUG9wdXAocG9wdXBfOGUwNTY4NjE5Y2E4NDUyZmE2YTQ0NTNhNGUzMGE0MDEpOwoKICAgICAgICAgICAgCiAgICAgICAgCiAgICAgICAgCiAgICAgICAgICAgIAoKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMzFkMzQxNmFjNDIxNGVkYWI0ZWJlNTEyNzAzMzE3ODggPSBMLmNpcmNsZSgKICAgICAgICAgICAgICAgIFs0MC42NjQzLC03My45Mzg1XSwKICAgICAgICAgICAgICAgIDEwMDAwMCwKICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICBjb2xvcjogJ2JsdWUnLAogICAgICAgICAgICAgICAgICAgIGZpbGxDb2xvcjogJyMwODNiN2InLAogICAgICAgICAgICAgICAgICAgIGZpbGxPcGFjaXR5OiAwLjYKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICApCiAgICAgICAgICAgICAgICAuYWRkVG8obWFwX2IzNjk4YWE4MTJiNjQ3NDI5Njc4Yzg5YTdkNTE0MzIxKTsKICAgICAgICAgICAgCiAgICAgICAgCiAgICAgICAgICAgIAogICAgICAgICAgICB2YXIgcG9wdXBfNzMyMTA4MmM5N2RkNDBjMWIwZTllMTgwNDczYTlhZTMgPSBMLnBvcHVwKHttYXhXaWR0aDogJzMwMCd9KTsKCiAgICAgICAgICAgIAogICAgICAgICAgICAgICAgdmFyIGh0bWxfMGY3ZDVmYjNkYzc2NDllM2EzZWZjYjY5YTY1ZjkwMzMgPSAkKCcgICAgICAgICA8ZGl2IGlkPSJodG1sXzBmN2Q1ZmIzZGM3NjQ5ZTNhM2VmY2I2OWE2NWY5MDMzIiAgICAgICAgICAgICAgICAgc3R5bGU9IndpZHRoOiAxMDAuMCU7IGhlaWdodDogMTAwLjAlOyI+ICAgICAgICAgICAgICAgICBOZXcgWW9yayB2aXNpdGVkIDIwPC9kaXY+ICAgICAgICAgICAgICAgICAnKVswXTsKICAgICAgICAgICAgICAgIHBvcHVwXzczMjEwODJjOTdkZDQwYzFiMGU5ZTE4MDQ3M2E5YWUzLnNldENvbnRlbnQoaHRtbF8wZjdkNWZiM2RjNzY0OWUzYTNlZmNiNjlhNjVmOTAzMyk7CiAgICAgICAgICAgIAoKICAgICAgICAgICAgY2lyY2xlX21hcmtlcl8zMWQzNDE2YWM0MjE0ZWRhYjRlYmU1MTI3MDMzMTc4OC5iaW5kUG9wdXAocG9wdXBfNzMyMTA4MmM5N2RkNDBjMWIwZTllMTgwNDczYTlhZTMpOwoKICAgICAgICAgICAgCiAgICAgICAgCiAgICAgICAgCiAgICAgICAgICAgIAogICAgICAgICAgICAgICAgdmFyIHBvbHlfbGluZV9mZWUzMzE1Yjk1NzE0NDkzYmI2MjQ4M2IyZjliZWRkMyA9IEwucG9seWxpbmUoCiAgICAgICAgICAgICAgICAgICAgW1s0MC42NjQyOTk5OTk5OTk5OTcsIC03My45Mzg1MDAwMDAwMDAwMDVdLCBbNDAuMDA5Mzk5OTk5OTk5OTk5LCAtNzUuMTMzMzAwMDAwMDAwMDA2XSwgWzM1LjIwODcsIC04MC44MzA2OTk5OTk5OTk5OTNdLCBbMzAuMzM3LCAtODEuNjYxMjk5OTk5OTk5OTk3XSwgWzMyLjc3NTcwMDAwMDAwMDAwMSwgLTk2Ljc5NjcwMDAwMDAwMDAwMV0sIFszMi43Nzk0OTk5OTk5OTk5OTksIC05Ny4zNDYyOTk5OTk5OTk5OTldLCBbMjkuNzgwNSwgLTk1LjM4NjMwMDAwMDAwMDAwNl0sIFszMC4zMDcyMDAwMDAwMDAwMDIsIC05Ny43NTZdLCBbMjkuNDcyNCwgLTk4LjUyNTA5OTk5OTk5OTk5NV0sIFs0MS44Mzc2MDAwMDAwMDAwMDIsIC04Ny42ODE3OTk5OTk5OTk5OTZdLCBbMzkuOTg0OCwgLTgyLjk4NDk5OTk5OTk5OTk5OV0sIFszOS43NzY2OTk5OTk5OTk5OTgsIC04Ni4xNDU4OTk5OTk5OTk5OTddLCBbMzkuNzYxODAwMDAwMDAwMDAxLCAtMTA0Ljg4MDZdLCBbNDcuNjIwNSwgLTEyMi4zNTA5XSwgWzM3Ljc3NTEwMDAwMDAwMDAwMiwgLTEyMi40MTkzMDAwMDAwMDAwMV0sIFszNy4yOTY5MDAwMDAwMDAwMDEsIC0xMjEuODE5M10sIFszNC4wMTkzOTk5OTk5OTk5OTcsIC0xMTguNDEwNzk5OTk5OTk5OTldLCBbMzIuODE1MzAwMDAwMDAwMDAxLCAtMTE3LjEzNTAwMDAwMDAwMDAxXSwgWzMzLjU3MjIwMDAwMDAwMDAwMiwgLTExMi4wODc5OTk5OTk5OTk5OV0sIFszMS44NDg0MDAwMDAwMDAwMDIsIC0xMDYuNDI3MDAwMDAwMDAwMDFdLCBbNDAuNjY0Mjk5OTk5OTk5OTk3LCAtNzMuOTM4NTAwMDAwMDAwMDA1XV0sCiAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogJ2JsdWUnLAogICAgICAgICAgICAgICAgICAgICAgICB3ZWlnaHQ6IDUsCiAgICAgICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IDAuMywKICAgICAgICAgICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgICBtYXBfYjM2OThhYTgxMmI2NDc0Mjk2NzhjODlhN2Q1MTQzMjEuYWRkTGF5ZXIocG9seV9saW5lX2ZlZTMzMTViOTU3MTQ0OTNiYjYyNDgzYjJmOWJlZGQzKTsKICAgICAgICAgICAgCiAgICAgICAgCiAgICAgICAgICAgIAogICAgICAgICAgICAgICAgCgogICAgICAgICAgICAgICAgbWFwX2IzNjk4YWE4MTJiNjQ3NDI5Njc4Yzg5YTdkNTE0MzIxLmZpdEJvdW5kcygKICAgICAgICAgICAgICAgICAgICBbWzI3LjQ3MjQsIC0xMjQuNDE5M10sIFs0OS42MjA1LCAtNzEuOTM4NV1dLAogICAgICAgICAgICAgICAgICAgIHsibWF4Wm9vbSI6IDR9CiAgICAgICAgICAgICAgICAgICAgKTsKICAgICAgICAgICAgCiAgICAgICAgCiAgICAgICAgCiAgICAgICAgPC9zY3JpcHQ+CiAgICAgICAg" style="position:absolute;width:100%;height:100%;left:0;top:0;"></iframe></div></div>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Optimized?">Optimized?<a class="anchor-link" href="#Optimized?">&#182;</a></h2><p>The visual plot seems to reveal what is seemingly not too circuitous path. Is it optimal? We will let you make that determination. But the point of this exercise was --</p>
<ol>
<li>That heuristics can provide near-optimal solutions when statistical solutions may not be conducive for realtime performance.</li>
<li>Locality preserving space filling indices, like s2 index and Hilbert space filling curve, may be used to quickly estimate nearby landmarks by a mere lookup of the index values versus computing a true Euclidean distance.</li>
<li>Such locality preserving indices, and their R Tree nature, may be used to turn complex theta joins into equality joins to compare two records in Hadoop because Hadoop like most relational engines does not allow non-equality joins without a costly cross-join operation.</li>
</ol>

</div>
</div>
</div>
        </div>
    </div>
    <footer>
        <div class="container row">
            <div class="pull-right"> <span class="copyright">Copyright © 2017. <a href="http://data-bloom.com">Data-Bloom</a></span></div>
        </div>
    </footer>

</html>
